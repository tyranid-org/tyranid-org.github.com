---
layout: default
---

  <div class="content">
    <h1>Tyr</h1>

     <p>
      The Tyr object, available on the client as <u>window.Tyr</u>, and usually imported on the server as <u>Tyr</u>, contains
      the namespace for Tyranid.
     </p>

     <article>
       <b class="property"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">$all</span>
       <p>
        This is a constant used with <a href="/#advancedPopulation">Advanced Population</a> that means to populate
        the field and grab all the properties. It can only be specified on a link.
       </p>
     </article>

     <article id="arraySort">
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">arraySort(array: array, sortObj: object): number</span><br>
       <p>This is similar to how <u>Array.sort()</u> works except that it takes a MongoDB-style sort definition object.</p>
       <p>Like <u>Array.sort()</u>, the array is sorted in-place.</p>
       <p>For example:</p>
   <pre><code class="js">const myArray = [ { b: 1 }, { b: 'alpha' }, {}, { b: 'alpha', c: 2 } ];
Tyr.arraySort(myArray, { b: 1, c: -1 });
// myArray is now: [ {}, { b: 1 }, { b: 'alpha', c: 2 }, { b: 'alpha' } ]
</code></pre>
       <p>See also <a href="#mongoCompare"><u>Tyr.mongoCompare()</u></a>.</p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">byId: { <i>collection id</i>: <a href="collection">Collection</a> }</span>
       <p>This is an hash of collections that Tyranid knows about indexed by collection id.</p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">byName: { <i>collection name</i>: <a href="collection">Collection</a> }</span>
       <p>This is an hash of collections that Tyranid knows about indexed by collection name.</p>
     </article>

     <article id="byUid">
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">byUid(uid: string, options: <a href="collection#options">Options</a>): <a href="document">Document</a></span>
       <p>
        This will find a document by its <a href="/#uids">UID</a>.
       </p>
     </article>

     <article id="byUids">
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">byUids(uids: string[], options: <a href="collection#options">Options</a>): <a href="document">Document</a>[]</span>
       <p>
        This will find an array of documents by their <a href="/#uids">UID</a>.</p>
       <p>The UIDs do not need to be from the same collection and this method is optimized
         to only query from each collection once.</p>
       <p><b>The returned array is <i>parallel</i> to the given <u>uids</u> array.</b>  If the same UID shows up multiple times in the input query, then
         the returned array will also have multiple instances, but the instances will be shared.  If a given UID does not exist in the database,
         then the corresponding entry will still be present, but it will contain <u>null</u>.</p>
     </article>

     <article>
       <b class="class"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig"><a href="collection">Collection</a></span>
     </article>

     <article>
       <b class="mixin"></b>
       <b class="server"></b>
       <span class="sig"><a href="component">Component</a></span>
     </article>

     <article>
       <b class="property"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">collections: <a href="collection">Collection</a>[]</span>
       <p>This is a list of all the collections that Tyranid knows about.</p>
     </article>

     <article>
       <b class="property"></b>
       <b class="server"></b>
       <span class="sig">components: <a href="component">Components</a>[]</span>
       <p>This is a list of all the components that are registerd with Tyranid.</p>
     </article>

     <article id="config">
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">config(opts: object): void</span>
       <p>This initializes Tyranid.  <u>opts</u> are as follows:</p>
       <pre>
{
  db: pmongo(<i>myDatabaseUrl</i>),
  logLevel: 'info',
  clientLogLevel: 'error',
  consoleLogLevel: 'info',
  dbLogLevel: 'info',
  indexes: true, <i>// ensure indexes are created (invokes <u>createIndexes()</u>)</i>
  migration: {
    migrate: true, <i>// indicates migrations should be run as part of configuration</i>
    dir: __dirname + '/path/to/migrations/directory',
    list: ['migration1', 'migration2'] <i>// list of approved migrations to run and the order in which to run them</i>
  },
  minify: false,
  permissions: {
    find: 'view',
    insert: 'edit',
    update: 'edit',
    remove: 'delete'
  },
  secure: <a href="secure">Secure</a>,
    <i>myServerName</i>: pmongo(<i>myServerDatabaseUrl</i>),
    ...
  },
  validate: <i>validateOpts</i>
}</pre>
      <p>If the <u>validate</u> option is not used, be sure to call <u>Tyr.validate()</u> once all of the collections
        have been imported.  See <a href="tyr#validate">Tyr.validate()</a> for an explanation of <u>validateOpts</u>.
      </p>
      <p>If the <u>minify</u> option is set to true (it also defaults to true) then the code generated by <u>/api/tyranid</u>
        will be minified.</p>
      <p>See <a href="log"><u>Log</u></a> for an explanation of the log level options.</p>

      <p>See <a href="secure"><u>Secure</u></a> for an explanation of the <u>secure</u> and <u>permissions</u> option.</p>
     </article>

     <article id="connect">
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">connect(opts: object): void</span>
       <p>
         This method connects Tyranid to external services like <a href="https://expressjs.com/">express</a> (which enables Tyranid's routing functionality) and
         <a href="https://nodejs.org/api/http.html#http_http">http</a> (which enables Tyranid's WebSocket support).  <u>opts</u> are as follows:</p>
       <pre>
{
  app: <i>Express</i>,
  auth: (req, res, next) => {}?): void,
  http: <i>Node http server</i>,
  store: <i>Express Session Store</i>
}</pre>
       <p><u>app</u> is the instance of express to connect to returned by <u>express()</u>.</p>
       <p><u>auth</u> is an optional callback that will be passed to all Tyranid routes via <u>.all(app)</u> before
        Tyranid routes are processed.  You can do additional validation and authorization here.</p>
       <p><u>http</u> is the instance of the http server (usually returned by <u>app.listen()</u>).  The HTTP server must be
        connected in order for WebSocket push capabilities to be enabled.</p>
       <p><u>store</u> is the instance of the <a href="https://github.com/expressjs/session">express-session</a> store passed into express (for example, connect-redis or connect-mongo).  This must be enabled
        for authentication capabilities to be available inside WebSocket requests.</p>
       <p><u>connect()</u> can optionally be called multiple times.  For example, you could connect to express in one call and to http in another.</p>
       <p>See <a href="/#client">Client</a> for more information.</p>
     </article>

     <article id="createIndexes">
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">createIndexes(): void</span>
       <p>This will create any indexes defined on collections if they do not already exist.</p>
     </article>

     <article>
      <b class="property"></b>
      <b class="server"></b>
      <span class="sig">db: <a href="http://mongodb.github.io/node-mongodb-native/">native MongoDB database (<u>Db</u>)</a></span>

      <p>This contains a reference to the underlying native MongoDB <u>Db</u> object.</p>
     </article>

     <article id="diff">
       <b class="property"></b>
       <b class="server"></b>
       <span class="sig"><a href="diff">diff</a>: object</span>
       <p>This contains Tyranid's diffing and patching functionality.  See <a href="diff">Diff & Patch</a>.</p>
     </article>

     <article>
      <b class="property"></b>
      <b class="server"></b>
      <b class="client"></b>
      <span class="sig">documentPrototype: object</span>

      <p>
       All <a href="document">Document</a> instances inherit from this object.  Add methods and properties to this
       object that you want to be available on all document instances.  It's recommended that all fields added to this
       object start with a '<u>$</u>' character and are <u>Object.defineProperty()</u>'ed to be non-enumerable.
      </p>
     </article>

     <article>
       <b class="class"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig"><a href="event">Event</a></span>
     </article>

     <article>
       <b class="class"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig"><a href="field">Field</a></span>
     </article>

     <article id="instanceId">
       <b class="property"></b>
       <b class="server"></b>
       <span class="sig">instanceId: string</span>
       <p>If there are multiple instances of Tyranid (for example, running across multiple webservers) then they will each have a distinct
        <i>instance id</i> that is available in this property.</p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">labelify(name: string): string</span>
       <p>This generates a humanized version of a camel-case name.  For example:<p>
       <table>
         <thead>
           <tr><th><i>name</i><th>labelify(<i>name</i>)
         </thead>
         <tr><td>age<td>Age
         <tr><td>firstName<td>First Name
       </table>
     </article>

     <article id="local">
       <b class="property"></b>
       <b class="server"></b>
       <span class="sig"><a href="local">local</a></span>
       <p>This provides access to Tyranid's <i>continuation local storage</i> capability.</p>
     </article>

     <article id="log">
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">trace|log|info|warn|error|fatal(opts): void</span><br>
       <p>This are aliases to the logging methods in <u>Log</u>, see <a href="log#log"><u>Log.log</u></a>.</p>
     </article>

     <article id="Log">
       <b class="class"></b>
       <b class="server"></b>
       <span class="sig"><a href="log">Log</a></span>
     </article>

     <article id="migrate">
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">migrate(): void</span>
       <p>This executes any migrations that are defined.  Use this method only when migrations are not run inside <a href="#config">config()</a> via <u>migrations.migrate = true</u>.</p>
     </article>

     <article id="mixin">
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">mixin(target: object, mixin: object): void</span><br>
       <p>This mixes in a <b>mixin</b> into a target object.  Both regular and prototype methods and properties are mixed.</p>
     </article>

     <article id="mongoCompare">
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">mongoCompare(a: any, b: any): number</span><br>
       <p>This is a comparator function that can be passed into methods like sort() that compares two values according
         to how MongoDB's sort operation works.</p>
       <p>If a < b, returns n such that n < 0; if a > b, returns n such that n > 0; if a === b, returns 0.</p>
       <p>See also <a href="#arraySort"><u>Tyr.arraySort()</u></a>.</p>
     </article>

     <article>
       <b class="class"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig"><a href="namePath">NamePath</a></span>
     </article>

     <article id="parseBson">
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">parseBson(value): any</span>
       <p>This will translate BSON-style objects into their "native" values.  For example:</p>
   <pre><code class="js">Tyr.parseBson(3) <i>=> 3</i>
Tyr.parseBson({ _bsontype: 'ObjectId', id: '...' }) <i>=> ObjectID('...')</i>
</code></pre>

     </article>

     <article id="parseUid">
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">parseUid(uid): { collection: <a href="collection">Collection</a>, id: <i>collection id type</i> }</span>
       <p>
        This will parse a <a href="/#uids">UID</a> into the collection and id that the uid refers to.
       </p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">pluralize(name: string): string</span>
       <p>This generates a plural form of a singular word.  For example:<p>
       <table>
         <thead>
           <tr><th><i>name</i><th>pluralize(<i>name</i>)
         </thead>
         <tr><td>boss<td>bosses
         <tr><td>day<td>days
         <tr><td>daisy<td>daisies
       </table>
     </article>

     <article>
       <b class="mixin"></b>
       <b class="server"></b>
       <span class="sig"><a href="secure">Secure</a></span>
     </article>

     <article>
       <b class="class"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig"><a href="type">Type</a></span>
     </article>

     <article id="u">
       <b class="property"></b>
       <b class="server"></b>
       <span class="sig"><a href="type">U</a></span>
       <p>This is a shortcut to <a href="units#parse"><u>Units.parse</u></a> and provides a shortcut to create new <a href="units">Units</a> instances.</p>
     </article>

     <article>
       <b class="class"></b>
       <b class="server"></b>
       <span class="sig"><a href="unit">Unit</a></span>
     </article>

     <article>
       <b class="class"></b>
       <b class="server"></b>
       <span class="sig"><a href="units">Units</a></span>
     </article>

     <article>
       <b class="class"></b>
       <b class="server"></b>
       <span class="sig"><a href="unitConversionError">UnitConversionError</a></span>
     </article>

     <article>
       <b class="class"></b>
       <b class="server"></b>
       <span class="sig"><a href="unitDegree">UnitDegree</a></span>
     </article>

     <article>
       <b class="class"></b>
       <b class="server"></b>
       <span class="sig"><a href="unitFactor">UnitFactor</a></span>
     </article>

     <article>
       <b class="class"></b>
       <b class="server"></b>
       <span class="sig"><a href="unitSystem">UnitSystem</a></span>
     </article>

     <article>
       <b class="class"></b>
       <b class="server"></b>
       <span class="sig"><a href="unitType">UnitType</a></span>
     </article>

     <article>
       <b class="class"></b>
       <b class="server"></b>
       <span class="sig"><a href="unitDegree">UnitDegree</a></span>
     </article>

     <article id="validate">
      <b class="method"></b>
      <b class="server"></b>
      <span class="sig">validate( dirOpts | dirOpts[] ): void</span>

      <p>
       If you did not specify the <u>validate</u> option in the <u>Tyr.config()</u> call, call this method once all of the collections and
       types have been imported and you want the entire metadata model compiled and linked (validated).  <u>dirOpts</u> are:
     </p>
<pre>{
  <i>// <b>dirOpts</b> supports two styles:</i>

  <i>// (1) globs:</i>
  glob: './**/model/*.js',    <i>// All model files in a model subdirectory</i>

  <i>// (2) directory with regex:</i>
  dir: './app/models',        <i>// All files in directory.</i>
  fileMatch<em>?</em>: '^tyr.*'       <i>// Provides a regex that files in the dir need to match.</i>
}</pre>
     <p><u>validate()</u> can optionally take an array of <u>dirOpts</u> so that you can specify multiple directories.</p>
     <p>If you are manually importing corrections then you do not need to pass in dirOpts.</p>

     </article>

     <article>
       <b class="class"></b>
       <b class="server"></b>
       <span class="sig"><a href="validationError">ValidationError</a></span>
     </article>

     <article id="valuesBy">
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">valuesBy(filter: Field => boolean): any[]</span>
       <p>This returns a unique list of all values that appear in any collection in the database for any field that matches the filter.</p>
       <p>For example, the following returns a list of all of the strings that occur in the database in any string field in any collection.</p>
       <pre>Tyr.valuesFor(field => field.type.def.name === 'string')</pre>
     </article>

    <h2 id="lodashUtilities"><u>ObjectId</u>-aware <u>lodash</u>-like utilities</h2>

     <article id="addToSet">
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">addToSet(array: array, ...values: any): void</span>
       <p>This adds all instances of <u>values</u> into <u>array</u> that are not already present.</p>
       <p>It can handle <u>ObjectId</u>s from different versions of the MongoDB native driver.</p>
     </article>

     <article id="cloneDeep">
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">cloneDeep(obj: object): object</span>
       <p>
        This is similar to <u>_.cloneDeep()</u> except that it can handle <u>ObjectId</u>s.
       </p>
     </article>

     <article id="indexOf">
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">indexOf(a: array, value: any): integer</span>
       <p>
        This is similar to <u>_.indexOf()</u> except that it can handle <u>ObjectId</u>s from different versions of the MongoDB native driver.
       </p>
     </article>

     <article id="isCompliant">
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">isCompliant(spec: any, value: any): boolean</span>
       <p>This function performs similarly to <u>_.matches()</u> except that the left object is a specification of what
        can appear on the right side.  For example, the left-hand side can specify an array of values and as long as the
        right-hand side contains one of those values, it will still be considered to be compliant.
     </article>

     <article id="isEqual">
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">isEqual(a, b): boolean</span>
       <p>
        This is similar to <u>_.isEqual()</u> except that it can handle <u>ObjectId</u>s from different versions of the MongoDB native driver.
       </p>
     </article>

     <article id="isObject">
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">isObject(value): boolean</span>
       <p>
        This is similar to <u>_.isObject()</u> except that it considers <u>ObjectId</u>s to be primitive values.
       </p>
     </article>

     <article id="isObjectId">
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">isObjectId(value): boolean</span>
       <p>
        This returns true if the value is an <u>ObjectId</u>.
       </p>
     </article>

     <article id="pullAll">
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">pullAll(a: array, ...values: any): void</span>
       <p>
        This is similar to <u>_.pullAll()</u> except that it can handle <u>ObjectId</u>s from different versions of the MongoDB native driver.
       </p>
     </article>

    <h2 id="asyncUtilities"><u>async</u> & <u>Promise</u> utilities</h2>

     <article id="eachAsync">
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">eachAsync&lt;A>(array: A[], visitor: async A => any): boolean</span>
       <p>This is like <u><i>array</i>.forEach()</u> except that the predicate function is asynchronous.</p>
       <p>The elements will be visited in sequence.</p>
     </article>

     <article id="everyAsync">
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">everyAsync&lt;A>(array: A[], predicate: async A => boolean): boolean</span>
       <p>This is like <u><i>array</i>.every()</u> except that the predicate function is asynchronous.</p>
     </article>

     <article id="filterAsync">
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">filterAsync&lt;A>(array: A[], filter: async A => boolean): boolean</span>
       <p>This is like <u><i>array</i>.filter()</u> except that the filter function is asynchronous.</p>
     </article>

     <article id="findAsync">
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">findAsync&lt;A>(array: A[], predicate: async A => boolean): A</span>
       <p>This is like <u><i>array</i>.find()</u> except that the predicate function is asynchronous.</p>
     </article>

     <article id="findIndexAsync">
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">findIndexAsync&lt;A>(array: A[], predicate: async A => boolean): integer</span>
       <p>This is like <u><i>array</i>.findIndex()</u> except that the predicate function is asynchronous.</p>
     </article>

     <article id="mapAsync">
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">mapAsync&lt;A, B>(array: A[], mapFn: async A => B): B[]</span>
       <p>This is like <u><i>array</i>.map()</u> except that the map function is asynchronous.</p>
     </article>

     <article id="mapAwait">
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">mapAwait(value: Promise | any, fn: any => any): Promise<any> | any</span>
       <p>This maps a value by the given function.  If the value is a promise, then the result will be a promise.</p>
       <p>This method permits writing mapping functions that work with values that are conditionally asynchronous.</p>
     </article>

     <article id="someAsync">
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">someAsync&lt;A>(array: A[], predicate: async A => boolean): boolean</span>
       <p>This is like <u><i>array</i>.some()</u> except that the predicate function is asynchronous.</p>
     </article>

    <h2 id="socketIo">socket.io</h2>

     <p>If <a href="https://socket.io"><u>socket.io</u></a> support has been enabled (see <a href="#connect"><u>connect()</u></a>) then the
      following properties are also available:</p>

     <article id="io">
       <b class="property"></b>
       <b class="server"></b>
       <span class="sig">io: object</span>
       <p>This contains a reference to the socket.io server.  You can use it to add your own events over the socket.io connection as well.</p>
     </article>

     <article id="socket">
       <b class="property"></b>
       <b class="client"></b>
       <span class="sig">socket: object</span>
       <p>This contains the socket.io client socket that Tyranid is using for the user.  You can use it to add your own events over the socket.io connection as well.</p>
     </article>

  </div>
