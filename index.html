<html>
 <head>
  <link href='http://fonts.googleapis.com/css?family=Megrim' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Metrophobic' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Lekton' rel='stylesheet' type='text/css'>
  <style>
body { font-family: 'Metrophobic', arial, serif; }
h1 {
  font-size:60px;
  font-family: 'Megrim', arial, serif;
  text-shadow: 8px 8px #ddd;
  margin: 8px 0 0 0;
  border-bottom: 5px solid #f70;
 }
h2 {
  font-size:24px;
  font-family: 'Megrim', arial, serif;
  text-shadow: 2px 2px #bbb;
  border-left: 5px solid #f70;
  padding-left: 8px;
 }
h3 {
  font-size:20px;
  font-family: 'Megrim', arial, serif;
  color: #f70;//#6666aa;
  //text-shadow: 2px 2px #bbb;
  margin: 0;
 }
h4 {
  font-size:18px;
  font-family: 'Megrim', arial, serif;
  color: #a50;//#6666aa;
  margin: 0;
}
pre {
  font-family: 'Lekton', courier, serif;
  color: #000;
}
pre i { color: #888; }
pre b { color: #444; }
.content {
  border:1px solid #000;
  padding:0 24px;
  background:#eee;
  margin:0 auto;
  width:1024px;
  -webkit-box-shadow:2px 2px 2px #aaa;
}
table {
  margin: 0;
}

a {
  color: #a50;
  text-decoration: none;
}
a:hover {
  border-bottom: 1px solid #f70;
}
a:visited {
  color: #630;
}
  </style>
 </head>
 <body>
  <a href="https://github.com/tyranid-org/tyranid"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/652c5b9acfaddf3a9c326fa6bde407b87f7be0f4/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6f72616e67655f6666373630302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png"></a>
  <div class="content">
   <h1>Tyranid.js</h1>
   <p><b>Tyranid</b> is a JavaScript-based, free, open-source, promise-based <b>metadata</b> library for generically working with data.</p>
   <p>Tyranid currently works primarily with MongoDB and can act as an ODM for MongoDB.</p>

   <h2>Status</h2>

   <a href="https://www.npmjs.com/package/tyranid"><img src="https://img.shields.io/npm/v/tyranid.svg" alt="npm version"></a>
   <a href="http://www.apache.org/licenses/LICENSE-2.0.html"><img src="https://img.shields.io/npm/l/tyranid.svg" alt="npm version"></a>
   <a href="https://travis-ci.org/tyranid-org/tyranid"><img src="https://api.travis-ci.org/tyranid-org/tyranid.svg"></a>

   <p>The library is currently in its early stages and the API will likely change frequently until version 1.0 is reached.</p>

   <h2>Download</h2>

   <p>The repository is hosted at Github:</p>

   <pre><a href="https://github.com/tyranid-org/tyranid">https://github.com/tyranid-org/tyranid</a></pre>

   <p>NPM:</p>

   <pre>npm install tyranid</pre>

   <h2>Community</h2>

   <p>Tyranid has a Slack account for discussion and support for Tyranid.  Click the button for an invite:</p>

   <script async defer src="http://tyranid-slack.herokuapp.com/slackin.js"></script>

   <h2>Guide</h2>

   <h3>Setup</h3>

   <pre>
var pmongo = require('promised-mongo'),
    Tyr    = require('tyranid');


<i>// Initialize Tyranid with a <a href="https://github.com/gordonmleigh/promised-mongo">promised-mongo</a> instance.</i>
Tyr.config({
  db: pmongo(myDatabaseUrl)
});

... import/require all types and schemas ...

<i>// Once all the types and schemas have been processed, invoke <b>Tyr.validate()</b> to have Tyranid link and validate
// all the references between the types and schemas.</i>
tyr.validate();

<i>// Optionally, you can pass in array of directory and filename regex match to Tyranid config to load the models and
// validate all at once.</i>
Tyr.config({
  db: pmongo(myDatabaseUrl),
  validate: [{ dir: './app/models' }] // all files in directory
});

-- or, with fileMatch --

Tyr.config({
  db: pmongo(myDatabaseUrl),
  validate: [{ dir: './app/models', fileMatch : '^tyr.*' }] // all files in directory that start with 'tyr'
});

   <h3>Types</h3>

<i>// You can define your own types.  Types can specify code to serialize to/from the browser, validation code, and so on.</i>
new Tyr.Type({
  name: 'ssn',
  notes: 'Defines a U.S. Social Security Number',
  <i>// SSNs will not be sent down to the browser by default for security reasons.</i>
  <i>// client can also be a function... </i>
  <i>// --> client : function(value) { return this.security === 'low' } </i>
  <i>// this will pass 'ssn' to the client if the value of 'security' in the containing document is 'low'</i>
  client: false,
  validate: function(path, field, value) {
    if (!!value.match(/^\d{3}-\d{2}-\d{4}$/)) {
      return new Tyr.ValidationError(path, 'is not a valid SSN.');
    }
  }
});

   <h3>Schemas</h3>

<i>// Metadata describing nested structures can be either placed inline or defined separately and reused.</i>
var RoleEntry = {
  is: 'object',
  fields: {
    network: { link: 'network' },
    role:    { link: 'role' }
  }
};

var User = new Tyr.Collection({
  <i>// Collections also have an id which is used to construct <b>universal ids</b> and other metadata purposes.</i>
  id: 'u00',
  name: 'user',
  dbName: 'users', <i>// defaults to value for "name"</i>
  fields: {
    <i>// Types like "email", "mongoid", "password", etc. are built in to Tyranid but can be overridden.</i>
    _id:        { is: 'mongoid' },
    email:      { is: 'email' },
    <i>// Shorthand:  "'password'" is equivalent to "{ is: 'password' }"</i>
    password:   'password',
    <i>// <b>required: true</b> will make this field required during validation.</i>
    firstName:  { is: 'string', required: true },
    lastName:   { is: 'string' },
    canLogIn:   { is: 'boolean' },
    birthDate:  { is: 'date' },
    ssn:        { is: 'ssn' },
    <i>// "org" links to another collection "organization".  <b>is</b> does not need to be specified -- Tyranid will infer
    // it based on the data type of the _id field in "organization".  Tyranid will also validate the schema and ensure that
    // it knows what "organization" is and update the reference with the Organization instance.</i>
    org:        { link: 'organization',
                  <i>// <b>as</b> can be applied to fields or collections to give a human-readable name suitable for using in a UI.</i>
                  as: 'Organization'
                },
    inactive:   { is: 'boolean' },
    comments:   { is: 'string',
                  <i>// <b>help</b> contains user-facing documentation that could be used in, for example, a tool tip.</i>
                  help: 'Place any public comments you would like to make here.',
                  <i>// <b>notes</b> contains internal, developer documentation.</i>
                  notes: 'Used for various notes that the user sets themselves.' },
    roles:      { is: 'array', of: RoleEntry }
  }
});

User.myStaticMethod = function() { ... };

User.prototype.fullName = function {
  return this.firstName + ' ' + this.lastName;
};

<i>// Tyranid can fetch collections by name.</i>
(Tyr.byName('user') instanceof Tyr.Collection) === true


    <h3>Finding & Saving</h3>

var user = new User();
user.firstName = 'David';

<i>// Built-in document methods and properties start with $ to avoid collisions with actual document property names.
// (It is illegal to have properties that start with $ in MongoDB.)</i>
user.$save().then(function() {
  <i>// save is complete</i>
});

<i>// Document level update, but only saves the shallow properties of the object, if the properties are set in the object.</i>
user.$update().then(function() {
  <i>// update is complete</i>
});

<i>// Collection level update, same as above.</i>
User.update({ ... }).then(function() {
  <i>// update is complete</i>
});

<i>// <b>collection</b>.db is an instance of a <a href="https://github.com/gordonmleigh/promised-mongo">promised-mongo</a> collection for when it is easier to just work directly with mongo.</i>
User.db.find({ ... }).then(function(users) {
});

<i>// Similar to the previous line except that users are wrapped as User objects.</i>
User.find({ ... }).then(function(users) {
});

<i>// Returns a single user wrapped as a User object.  Parameters are the same as MongoDB's findOne() API.</i>
User.findOne({ ... }).then(function(users) {
});

<i>// Behaves the same as MongoDB's findAndModify() API.  If using <b>timestamps</b> and the <b>update</b> option, Tyranid will add in
// an <b>updatedAt</b> update as well.</i>
User.findAndModify({ ... }).then(function(users) {
});

<i>// Returns the user with ObjectId('AF8...123') wrapped as a User object.  <b>byId(id)</b> is a shortcut for
// User.findOne({ _id: id }).</i>
User.byId(ObjectId('AF8...123')).then(function(user) {
});

    <h3>Labels</h3>

<i>// Finds the document in an emum collection where the label is equal to the given label.</i>
let country = Country.byLabel('Germany');

<i>// Returns the value of the label field for the document.  The following would output "Germany" if it was the record for Germany.</i>
Country.labelFor(country)

<i>// The same method is available on document instances as a dynamic property as well:</i>
country.$label


    <h3>Computed Values</h3>

<i>// Computed values can be created by specifying a <b>get</b> option on a property.  By default computed values will:
//  (a) not be stored in the database unless the <b>db</b> property is set to true, and
//  (b) not be sent down to the client with toClient() unless the <b>client</b> property is set to true.</i>
var User = new Tyr.Collection({
  <i>...</i>
  fields: {
    <i>...</i>
    firstName:  { is: 'string' },
    lastName:   { is: 'string' },
    fullName:   { is: 'string', get: function() { return this.firstName + ' ' + this.lastName; }, db: true, client: true },
    <i>...</i>
  }
});

    <h3>Population</h3>

<i>// Tyranid can traverse links and provide join-like functionality.</i>
User.populate('org', users).then(function(users) {
  <i>// An <b>org$</b> property on each user will be added with an actual organization document.</i>
});

<i>// If your field that you are populating ends with "Id", the populated field will be the same name with the "Id" removed
// instead of a "$" appended.</i>
User.populate('orgId', users).then(function(users) {
  <i>// An <b>org</b> property on each user will be added with an actual organization document.</i>
});

<i>// If you leave off the second array of documents parameter to <b>populate()</b> it will return a curried version of itself
// that can be inserted into a find promise chain.</i>
User.find({ ... }).then(User.populate('org'));

<i>// You can also populate a single instance:</i>
user.$populate('org');

<i>// You can also pass in pathnames to populate.  Arrays will also be populated as well.</i>
user.$populate('roles.role');

<i>// You can also pass in an array of property names to populate.</i>
user.$populate([ 'org', 'roles.role' ]);

    <h4>Advanced Population</h4>
<i>// The advanced form of population allows you to perform nested populations and specify the projections of populations.</i>

<i>// Population often uses an "$all" constant.  "Tyr.$all" is defined as "Tyr.$all = '$all'".  You might want to do the following:</i>
var Tyr  = require('tyranid'),
    $all = Tyr.$all;

<i>// The following says to populate the <b>org</b> field and also populate the "_id", "name", and "network" properties from <b>role</b>.
// Additionally, the <b>network$</b> property on roles will also be populated, but only the names will be retrieved, not the _id's
// (or any other properties ... _id's are included by default in projections according to MongoDB conventions).</i>
user.$populate({ org: $all, 'roles.role': { name: 1, network: { _id: 0, name: 1 } } });

<i>// The following says to grab all the properties off of <b>role</b> and to also populate the <b>network</b> property.</i>
user.$populate({ 'roles.role': { $all: 1, network: $all } });

<i>// "$all: 1" can also be written "$all: $all".  If using ES6, this means it can be written as just "$all".
// For example the previous can be written as:</i>
user.$populate({ 'roles.role': { $all, network: $all } });

<i>// In general the values that can follow a property pathname are:</i>

<table>
 <tr><td style="width:70px">0</td><td><i>Means exclude this property.  Similar to MongoDB's projection.</i></td></tr>
 <tr><td>1</td><td><i>Means include this property.  Similar to MongoDB's projection.</i></td></tr>
 <tr><td>$all</td><td><i>Means to populate the field and grab all the properties.  Can only be specified on a link.</i></td></tr>
 <tr><td>{ <i>...</i> }</td><td><i>Recursively list properties to populate.  Can only be specified on a link.</i></td></tr>
</table>
<i>// In general, population will not query the same document more than once.  If the document shows up in multiple places
// with different projections all locations will contain the same document which will contain a superset of the projections.
// This also means that population can be used to populate relationships with cycles.</i>

    <h4>Denormalization</h4>

<i>// Tyranid can also store populations when a document is saved or updated.  For example, this can be useful for cases where
// you need a a few properties redundantly stored in a collection so you have more indexing options.</i>

<i>// This option shows up as a <b>denormal</b> option when defining a field.  For example, the following would store a
// copy of the Organization's name field redundantly on the User collection.  Similar to how population would store populated
// org data under a variable "org$", denormalized data will get stored as "org_".  In the following example, the org link would
// be available as "user.org" while the denormalized name would be available as "user.org_.name".</i>
var User = new Tyr.Collection({
  <i>...</i>
  fields: {
    <i>...</i>
    org:  { link: 'org', <b>denormal: { name: 1 }</b> },
    <i>...</i>
  }
});

    <h3>Validation</h3>

<i>// The following will run validations on the object and return an array of <b>ValidationError</b>s.</i>
user.$validate();


    <h3>Timestamps</h3>

<i>// If you set <b>timestamps: true</b> when defining your collection then Tyranid will update the timestamps <b>createdAt</b> and
// <b>updatedAt</b> when you create a new object using Tyranid's save() or insert() methods and it will update <b>updatedAt</b> when
// you use Tyranid's update() methods.</i>
var MyCollection = new Tyr.Collection({
  <i>...</i>
  timestamps: true,
  <i>...</i>
});

    <h3>Universal IDs (UIDs)</h3>

<i>// Universal IDs are a way of polymorphically working with data.  For example, if you need to have an array of IDs
// from multiple collections UIDs will let you do this.

// Returns "u00AF8...123".  <b>u00</b> was specified as the collection ID for User.</i>
User.idToUid(ObjectId('AF8...123'))

<i>// returns "u00AF8...123" if user._id is ObjectId("AF8...123").</i>
user.$uid

<i>// returns { collection: User, id: ObjectId('AF8...123') }</i>
Tyr.parseUid('u00AF8...123')

<i>// Tyranid can fetch documents by UID without having to specify the collection for code that generically works with data.</i>
Tyr.byUid('u00AF8...123').then(function(user) {
  <i>// <b>user</b> is a User instance with mongo ID ObjectId('AF8...123').</i>
});

    <h3>Browser Serialization</h3>

<i>// Returns a <b>User</b> instance while also performing security checks, converting the _id to a MongoId, validating data,
// and so on.</i>
User.fromClient({ _id: 'AF8...123', firstName: 'Jack', ... })

<i>// Returns a "Plain Old JavaScript Object" (POJO)/JSON object that is suitable for sending down to client while also
// performing security checks.</i>
res.json(user.$toClient())

<i>// Translates an existing object to the client when the object is not an instance of <b>User</b> (i.e. came directly from Mongo).</i>
res.json(User.toClient(obj))

    <h3>Static Data</h3>

<i>// Tyranid supports efficiently modeling static data as well.  This is good for modeling enumerations and linking to them.
// It also allows you to work with static and non-static data in an isomorphic way.</i>
var Continent = new Tyr.Collection({
  id: 'c0a',
  name: 'continent',
  dbName: 'continents',
  <i>// This causes enumeration constants to be defined on the collection for each of the enumerated values.</i>
  enum: true,
  fields: {
    _id:        { is: 'integer' },
    <i>// <b>label</b> indicates that this field is the label value for this collection.</i>
    name:       { is: 'string', label: true },
    code:       { is: 'string' },
    pcmName:    { is: 'string' }
  },
  values: [
    [ '_id', 'name',       'code', 'pcmName' ],

    [ 4328, 'Africa',        'AF', 'Africa'  ],
    [ 4329, 'Antartica',     'AN', null      ],
    [ 4330, 'Asia',          'AS', 'Europe'  ],
    [ 4331, 'Europe',        'EU', 'Europe'  ],
    [ 4332, 'North America', 'NA', 'NA'      ],
    [ 4333, 'Oceania',       'OC', 'Oceania' ],
    [ 4334, 'South America', 'SA', 'SA'      ]
  ]
});

Continent.prototype.isContinent = function() {
  return true;
};

<i>// This evaluates to true since the <b>enum</b> flag was turned on.  "NORTH_AMERICA" is derived from the name "North America"
// since the <b>name</b> field was marked as the <b>label</b> for the Continent collection.</i>
Continent.NORTH_AMERICA._id === 4332

<i>// The static data instances are also instances of the collection so methods and behaviors are available.</i>
Continent.NORTH_AMERICA.isContinent()
   </pre>

   <h2>License</h2>

   <p>The project is licensed under <a href="http://www.apache.org/licenses/LICENSE-2.0.html">Apache License, Version 2.0</a>.

   <p>Patches are gladly accepted from their original author.  Along with any patches, please state that the patch is your original work and that you license the work to the Tyranid project under the Apache License, Version 2.0 open-source license.</p>

   <h2>Further Information</h2>

   <p>If you have any questions, please send email to <a href="mailto:info@tyranid.org">info@tyranid.org</a>.</p>
  </div>
 </body>
</html>
