---
layout: default
---

  <a href="https://github.com/tyranid-org/tyranid"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/652c5b9acfaddf3a9c326fa6bde407b87f7be0f4/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6f72616e67655f6666373630302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png"></a>

  </div>

  <div class="content">
   <h1>Tyranid.js</h1>
   <p><b>Tyranid</b> is a JavaScript-based, free, open-source, promise-based <b>metadata framework</b> for generically working with data.</p>
   <p>Tyranid currently works primarily with MongoDB and can act as an ODM for MongoDB.</p>

   <h2>Status</h2>

   <a href="https://www.npmjs.com/package/tyranid"><img src="https://img.shields.io/npm/v/tyranid.svg" alt="npm version"></a>
   <a href="http://www.apache.org/licenses/LICENSE-2.0.html"><img src="https://img.shields.io/npm/l/tyranid.svg" alt="npm version"></a>
   <a href="https://travis-ci.org/tyranid-org/tyranid"><img src="https://api.travis-ci.org/tyranid-org/tyranid.svg"></a>

   <p>The library is currently in its early stages and the API will likely change frequently until version 1.0 is reached.</p>

   <h2>Download</h2>

   <p>The repository is hosted at Github:</p>

   <pre><a href="https://github.com/tyranid-org/tyranid">https://github.com/tyranid-org/tyranid</a></pre>

   <p>NPM:</p>

   <pre>npm install tyranid</pre>

   <h2>Community</h2>

   <p>Tyranid has a Slack account for discussion and support for Tyranid.  Click the button for an invite:</p>

   <script async defer src="http://tyranid-slack.herokuapp.com/slackin.js"></script>

   <h2>Guide</h2>




   <h3>Setup</h3>

   <pre><code class="js">var pmongo = require('promised-mongo'),
    Tyr    = require('tyranid');

<i>// Initialize Tyranid with a <a href="https://github.com/gordonmleigh/promised-mongo">promised-mongo</a> instance.</i>
Tyr.config({
  db: pmongo(myDatabaseUrl)
});
<p>... import/require all types and schemas:</p>
<i>// Once all the types and schemas have been processed, invoke <b>Tyr.validate()</b> to have Tyranid link and validate
// all the references between the types and schemas.</i>
Tyr.validate();

<i>// Optionally, you can pass in array of directory and filename regex match to Tyranid config to load the models and</i>
<i>// validate all at once.</i>
Tyr.config({
  db: pmongo(myDatabaseUrl),
  validate: [{ dir: './app/models' }] <i>// all files in directory</i>
});
<p>... or, with fileMatch:</p>
Tyr.config({
  db: pmongo(myDatabaseUrl),
  validate: [{ dir: './app/models', fileMatch : '^tyr.*' }] <i>// all files in directory that start with 'tyr'</i>
});
</code></pre>




   <h3>Types</h3>
<p>You can define your own types.  Types can specify code to serialize to/from the browser, validation code, and so on.</p>
<pre><code class="js">new Tyr.Type({
  name: 'ssn',
  notes: 'Defines a U.S. Social Security Number',
  <i>// SSNs will not be sent down to the browser by default for security reasons.</i>
  <i>// client can also be a function... </i>
  <i>// --> client : function(value) { return this.security === 'low' } </i>
  <i>// this will pass 'ssn' to the client if the value of 'security' in the containing document is 'low'</i>
  client: false,
  validate: function(path, field, value) {
    if (!!value.match(/^\d{3}-\d{2}-\d{4}$/)) {
      return new Tyr.ValidationError(path, 'is not a valid SSN.');
    }
  }
});
</code></pre>




   <h3>Schemas</h3>

<pre><code class="js"><i>// Metadata describing nested structures can be either placed inline or defined separately.</i>
var RoleEntry = {
  is: 'object',
  fields: {
    network: { link: 'network' },
    role:    { link: 'role' }
  }
};

var User = new Tyr.Collection({
  <i>// Collections also have an id which is used to construct <b>universal ids</b> and other metadata purposes.</i>
  id: 'u00',
  name: 'user',
  dbName: 'users', <i>// defaults to value for "name"</i>
  fields: {
    <i>// Types like "email", "mongoid", "password", etc. are built in to Tyranid but can be overridden.</i>
    _id:        { is: 'mongoid' },
    userId:     { is: 'mongoid', label: 'User ID' },
    email:      { is: 'email' },
    <i>// Shorthand:  "'password'" is equivalent to "{ is: 'password' }"</i>
    password:   'password',
    <i>// <b>required: true</b> will make this field required during validation.</i>
    firstName:  { is: 'string', required: true },
    lastName:   { is: 'string' },
    canLogIn:   { is: 'boolean' },
    birthDate:  { is: 'date' },
    ssn:        { is: 'ssn' },
    <i>// "org" links to another collection "organization".  <b>is</b> does not need to be specified -- Tyranid will infer</i>
    <i>// it based on the data type of the _id field in "organization".  Tyranid will also validate the schema and ensure that</i>
    <i>// it knows what "organization" is and update the reference with the Organization instance.</i>
    org:        { link: 'organization',
                  <i>// <b>as</b> can be applied to fields or collections to give a human-readable name suitable for using in a UI.</i>
                  as: 'Organization'
                },
    inactive:   { is: 'boolean' },
    comments:   { is: 'string',
                  <i>// <b>help</b> contains user-facing documentation that could be used in, for example, a tool tip.</i>
                  help: 'Place any public comments you would like to make here.',
                  <i>// <b>note</b> contains internal, developer documentation.</i>
                  notes: 'Used for various notes that the user sets themselves.' },
    roles:      { is: 'array', of: _.cloneDeep(RoleEntry) }
  },
  <i>// Can optionally specify a field to act as this collection's primary key, defaulting to <b>_id</b>.</i>
  <i>// This field will be used for document retrieval, validation, and, most importantly, links and population.</i>
  <i>// Setting <b>defaultMatchIdOnInsert</b> will cause Tyranid to match <b>_id</b> to this field's value on</i>
  <i>// insert (instead of generating a new ObjectId).</i>
  primaryKey: { field: 'userId', defaultMatchIdOnInsert: true }
});

User.myStaticMethod = function() { ... };

User.prototype.fullName = function {
  return this.firstName + ' ' + this.lastName;
};

<i>// Tyranid can fetch collections by name.</i>
(Tyr.byName('user') instanceof Tyr.Collection) === true
</code></pre>

     <h4 id="dynamicSchemas">Dynamic Schemas</h4>
<p>Tyranid also supports <b>dynamic schemas</b> that can be added at runtime via storing metadata in the database.
The following adds a "westTotal" property to User but only for users that belong to Organization 1:</p>
<pre><code class="js">Tyr.byName('tyrSchema').save({
  collection: User.id,
  match: {
    org: 1
  },
  type: Tyr.byName('tyrSchemaType').PARTIAL._id,
  def: {
    fields: {
      westTotal: { is: 'integer' }
    }
  }
});
</code></pre>
<p>You can get a list of fields that apply to a specific document using <b>fieldsFor</b>:</p>
<pre><code class="js">const fields = await User.fieldsFor({ org: 1 });
</code></pre>




    <h3>Finding & Saving</h3>
<pre><code class="js">var user = new User();
user.firstName = 'David';

<i>// Built-in document methods and properties start with $ to avoid collisions with actual document property names.
// (It is illegal to have properties that start with $ in MongoDB.)</i>
user.$save().then(function() {
  <i>// save is complete</i>
});

<i>// Document level update, but only saves the shallow properties of the object, if the properties are set in the object.</i>
user.$update().then(function() {
  <i>// update is complete</i>
});

<i>// Collection level update, same API as promised-mongo/mongo shell update().</i>
User.update(query, update, opts).then(function() {
  <i>// update is complete</i>
});

<i>// <b>collection</b>.db is an instance of a <a href="https://github.com/gordonmleigh/promised-mongo">promised-mongo</a> collection for when it is easier to just work directly with mongo.</i>
User.db.find({ ... }).then(function(users) {
});

<i>// Similar to the previous line except that users are wrapped as User objects.</i>
User.find({ ... }).then(function(users) {
});

<i>// Returns a single user wrapped as a User object.  Parameters are the same as MongoDB's findOne() API.</i>
User.findOne({ ... }).then(function(users) {
});

<i>// Behaves the same as MongoDB's findAndModify() API.  If using <b>timestamps</b> and the <b>update</b> option, Tyranid will add in
// an <b>updatedAt</b> update as well.</i>
User.findAndModify({ ... }).then(function(users) {
});

<i>// Returns the user with ObjectId('AF8...123') wrapped as a User object.  <b>byId(id)</b> is a shortcut for
// User.findOne({ _id: id }).</i>
User.byId(ObjectId('AF8...123')).then(function(user) {
});

<i>// Same as User.db.remove()</i>
User.remove({ _id: id });
</code></pre>





    <h3 id="labels">Labels</h3>

<p>Labels can be defined for documents using the <u>labelField</u> option:</p>

<pre><code class="js">var Continent = new Tyr.Collection({
  <i>...</i>
  fields: {
    <i>...</i>
    <i>// <b>labelField</b> indicates that this field is the label value for this collection.</i>
    name:       { is: 'string', labelField: true },
    <i>...</i>
  }
});
</code></pre>

<p>Examples using labels are:</p>

<pre><code class="js"><i>// Finds the document in an emum collection where the label is equal to the given label.</i>
let country = Country.byLabel('Germany');

<i>// Returns the value of the label field for the document.  The following would output "Germany":</i>
Country.labelFor(country)

<i>// The same method is available on document instances as a dynamic property as well:</i>
country.$label
</code></pre>

<p>Collections and Fields also support a <b>label</b> property.  If no label is provided one will be generated from the <b>name</b>.</p>
<pre><code class="js">User.label                    <i>=> 'User'</i>
User.def.fields.userId.label  <i>=> 'User ID'</i>
User.def.fields.email.label   <i>=> 'Email'</i>
</code></pre>




    <h3>Fields</h3>
<pre><code class="js"><i>// Fields support a <b>name</b> property.</i>
User.def.fields.email.name <i>=> 'email'</i>

<i>// Fields also support a <b>path</b> property.</i>
User.def.fields.roles.def.of.def.fields.network.path <i>=> 'roles.network'</i>
</code></pre>




    <h3 id="links">Links</h3>

<p>Fields of type <u>link</u> support a <u>where</u> property.  For example:</p>

<pre><code class="js">var User = new Tyr.Collection({
  id : 'u00',
  name: 'user',
  fields: {
    <i>...</i>
    <i>// Managers have to be in the same organization as the user.</i>
    manager:   { link: 'user', where: { organizationId: $this.organizationId } },
    <i>...</i>
  }
});
</code></pre>




    <h3 id="client">Client</h3>
<p>Tyranid will automatically generate collections, fields, and so on for use on the client based upon the server metadata.</p>
<p>Only collections that have <u>client: true</u> will have their metadata sent to the client.  By default collections are server-only.</p>
<p>Client-side Tyranid is enabled by the following two steps:</p>
<ol>
  <li>Initialize routing.  <u>express</u> is the instance returned by <u>express()</u>.  <u>auth</u> is a callback that will be placed ahead
    of all routes (you can do additional authorization in this function).
<pre><code class="js">Tyr.express(express, auth);</code></pre>
  <li>Import client-side code into your browser session:
<pre>&lt;script src="/api/tyranid">&lt;/script></pre>
</ol>

<p>The Tyranid namespace is available on the client as <u>window.Tyr</u>.</p>
<p style="width:904px;"><b class="client"></b>Methods, properties, and classes that are available on the client are identified in the documentation by the client tag:</p>




    <h3 id="computedProperties">Computed Properties</h3>
<p>Computed values can be created by specifying a <u>get</u> option on a property.  By default computed values will:
  <ol>
    <li>not be stored in the database unless the <u>db</u> property is set to true, and
    <li>not be sent down to the client with <u>toClient()</u> unless the <u>client</u> property is set to true.
  </ol>
</p>
<pre><code class="js">var User = new Tyr.Collection({
  <i>...</i>
  fields: {
    <i>...</i>
    firstName:  { is: 'string' },
    lastName:   { is: 'string' },
    fullName:   { is: 'string', get: function() { return this.firstName + ' ' + this.lastName; }, db: true, client: true },
    <i>...</i>
  }
});
</code></pre>
<p>By default <u>get</u> methods are isomorphic if <a href="#client">client-side functionality</a> is enabled.  If you want the function to only appear
on the server you can use <u>serverGet</u> instead.  You can also optionally specify a client-specific version using <u>clientGet</u>.

<h4>Set</h4>

<p><u>set</u>, <u>clientSet</u>, <u>serverSet</u> also exist to provide a programmatic setter for properties as well.</p>



    <h3 id="methods">Methods</h3>
<p>Tyranid supports defining methods in metadata.</p>

<pre><code class="js">var User = new Tyr.Collection({
  <i>...</i>
  methods: {
    <i>methodName</i>: {
      fn(<i>parameters</i>) { <i>...</i> },
    },
    <i>...</i>
  },
  <i>...</i>
});
</code></pre>

<p>By default <u>fn</u> methods are isomorphic if <a href="#client">client-side functionality</a> is enabled.  If you want the method to only appear
on the server you can use <u>serverFn</u> instead.  You can also optionally specify a client-specific version using <u>clientFn</u>.


    <h3 id="population">Population</h3>
<pre><code class="js"><i>// Tyranid can traverse links and provide join-like functionality.</i>
User.populate('org', users).then(function(users) {
  <i>// An <b>org$</b> property on each user will be added with an actual organization document.</i>
});

<i>// If your field that you are populating ends with "Id", the populated field will be the same name with the "Id" removed
// instead of a "$" appended.</i>
User.populate('orgId', users).then(function(users) {
  <i>// An <b>org</b> property on each user will be added with an actual organization document.</i>
});

<i>// If you leave off the second array of documents parameter to <b>populate()</b> it will return a curried version of itself
// that can be inserted into a find promise chain.</i>
User.find({ ... }).then(User.populate('org'));

<i>// You can also populate a single instance:</i>
user.$populate('org');

<i>// You can also pass in pathnames to populate.  Arrays will also be populated as well.</i>
user.$populate('roles.role');

<i>// You can also pass in an array of property names to populate.</i>
user.$populate([ 'org', 'roles.role' ]);
</code></pre>
    <h4 id="advancedPopulation">Advanced Population</h4>
<p>The advanced form of population allows you to perform nested populations and specify the projections of populations.</p>
<pre><code class="js"><i>// Population often uses an "$all" constant.  "Tyr.$all" is defined as "Tyr.$all = '$all'".</i>
var Tyr  = require('tyranid'),
    $all = Tyr.$all;

<i>// The following says to populate the <b>org</b> field and also populate the "_id", "name", and "network" properties from <b>role</b>.
// Additionally, the <b>network$</b> property on roles will also be populated, but only the names will be retrieved, not the _id's
// (or any other properties ... _id's are included by default in projections according to MongoDB conventions).</i>
user.$populate({ org: $all, 'roles.role': { name: 1, network: { _id: 0, name: 1 } } });

<i>// The following says to grab all the properties off of <b>role</b> and to also populate the <b>network</b> property.</i>
user.$populate({ 'roles.role': { $all: 1, network: $all } });

<i>// "$all: 1" can also be written "$all: $all".  If using ES6, this means it can be written as just "$all".
// For example the previous can be written as:</i>
user.$populate({ 'roles.role': { $all, network: $all } });
</code></pre>
<p>The values that can follow a property pathname are:</p>
<table>
 <tr><td style="width:70px">0</td><td><i>Means exclude this property.  Similar to MongoDB's projection.</i></td></tr>
 <tr><td>1</td><td><i>Means include this property.  Similar to MongoDB's projection.</i></td></tr>
 <tr><td>$all</td><td><i>Means to populate the field and grab all the properties.  Can only be specified on a link.</i></td></tr>
 <tr><td>{ <i>...</i> }</td><td><i>Recursively list properties to populate.  Can only be specified on a link.</i></td></tr>
</table>
<p>In general, population will not query the same document more than once.  If the document shows up in multiple places
with different projections all locations will contain the same document which will contain a superset of the projections.
This also means that population can be used to populate relationships with cycles.</p>
    <h4 id="denormalization">Denormalization</h4>
<p>Tyranid can also store populations when a document is saved or updated.  For example, this can be useful for cases where
you need a a few properties redundantly stored in a collection so you have more indexing options.</p>
<p>This capability shows up as a <b>denormal</b> option when defining a field.  For example, the following would store a
copy of the Organization's name field redundantly on the User collection.  Similar to how population would store populated
org data under a variable "org$", denormalized data will get stored as "org_".  In the following example, the org link would
be available as "user.org" while the denormalized name would be available as "user.org_.name".</p>
<pre><code class="js">var User = new Tyr.Collection({
  <i>...</i>
  fields: {
    <i>...</i>
    org:  { link: 'org', <b>denormal: { name: 1 }</b> },
    <i>...</i>
  }
});
</code></pre>




    <h3>Validation</h3>
<p>The following will run validations on the object and return an array of <a href="validationError">ValidationError</a>s:</p>
<pre><code class="js">user.$validate();
</code></pre>



    <h3 id="timestamps">Timestamps</h3>
<p>If you set <b>timestamps: true</b> when defining your collection then Tyranid will update the timestamps <b>createdAt</b> and
<b>updatedAt</b> when you create a new object using Tyranid's save() or insert() methods and it will update <b>updatedAt</b> when
you use Tyranid's update() methods.</p>
<pre><code class="js">var MyCollection = new Tyr.Collection({
  <i>...</i>
  timestamps: true,
  <i>...</i>
});
</code></pre>




    <h3 id="uids">Universal IDs (UIDs)</h3>
<p>A UID is a string formed by concatenating a collection ID with a document ID.</p>
<p>Universal IDs are a way of polymorphically working with data.  For example, if you need to have an array of IDs
from multiple collections UIDs will let you do this.</p>
<pre><code class="js"><i>// Returns "u00AF8...123".  <b>u00</b> was specified as the collection ID for User.</i>
User.idToUid(ObjectId('AF8...123'))

<i>// returns "u00AF8...123" if user._id is ObjectId("AF8...123").</i>
user.$uid

<i>// returns { collection: User, id: ObjectId('AF8...123') }</i>
Tyr.parseUid('u00AF8...123')

<i>// Tyranid can fetch documents by UID without having to specify the collection for code that generically works with data.</i>
Tyr.byUid('u00AF8...123').then(function(user) {
  <i>// <b>user</b> is a User instance with mongo ID ObjectId('AF8...123').</i>
});
</code></pre>





    <h3>Browser Serialization</h3>
<pre><code class="js"><i>// Returns a <b>User</b> instance while also performing security checks, converting the _id to a MongoId, validating data,
// and so on.</i>
User.fromClient({ _id: 'AF8...123', firstName: 'Jack', ... })

<i>// Returns a "Plain Old JavaScript Object" (POJO)/JSON object that is suitable for sending down to client while also
// performing security checks.</i>
res.json(user.$toClient())

<i>// Translates an existing object to the client when the object is not an instance of <b>User</b> (i.e. came directly from Mongo).</i>
res.json(User.toClient(obj))
</code></pre>





    <h3 id="paths">Paths</h3>
<p><b>Paths</b> are a string-based syntax for referencing fields inside documents.  For example, the following structure:</p>
<pre><code class="js">{
  name: 'Jack',
  siblings: [
    { name: 'Jill' },
    { name: 'Joe' }
  ],
  address: {
    state: 'WI'
  }
}
</code></pre>
<p>has the following paths:</p>
<table>
  <tr><td>name</td><td>'Jack'</td></tr>
  <tr><td>siblings.0.name</td><td>'Jill'</td></tr>
  <tr><td>siblings._.name</td><td>'Jill', 'Joe'</td></tr>
  <tr><td>address.state</td><td>'WI'</td></tr>
</table>
</p>
<p>Collections contain a <a href="collection#fields"><u>fields</u></a> hash which make it easier to work with paths.</p>
    <h4>Arrays</h4>
<p>Arrays have a special syntax.  When referring to the contents of an array in a generic sense, you use "<u>._</u>".  When referring to a
particular element you use "<u>.<i>array index</i></u>".</p>
<p>For example, <u>siblings</u> refers to an array, <u>siblings._</u> refers to the type of contents of the array (an object), and
<u>siblings._.name</u> refers to a specific property inside that object that is inside the array.</p>
<p>This array syntax can be simplified (i.e. <u>siblings._.name</u> => <u>siblings.name</u>) in certain circumstances,
for example when used inside MongoDB queries.  This is called a <i>simplified path</i> and is available as
<a href="field#spath"><u>Field.spath</u></a>.</p>
    <h4><a href="namePath">NamePath</a></h4>
<p>The <a href="collection#parsePath"><i>collection</i>.parsePath(<i>path</i>)</a> method can be used to create <a href="namePath">NamePath</a>
  objects which are useful for parsing paths.</p>




    <h3 id="staticData">Static Data</h3>
<p>Tyranid supports efficiently modeling static data as well.  This is good for modeling enumerations and linking to them.
It also allows you to work with static and non-static data in an isomorphic way.</p>
<pre><code class="js">var Continent = new Tyr.Collection({
  id: 'c0a',
  name: 'continent',
  dbName: 'continents',
  <i>// This causes enumeration constants to be defined on the collection for each of the enumerated values.</i>
  enum: true,
  fields: {
    _id:        { is: 'integer' },
    <i>// <b>labelField</b> indicates that this field is the label value for this collection.</i>
    name:       { is: 'string', labelField: true },
    code:       { is: 'string' },
    altName:    { is: 'string', label: 'Alternate Name' }
  },
  values: [
    [ '_id', 'name',       'code', 'altName' ],

    [ 4328, 'Africa',        'AF', null      ],
    [ 4329, 'Antartica',     'AN', null      ],
    [ 4330, 'Asia',          'AS', null      ],
    [ 4331, 'Europe',        'EU', null      ],
    [ 4332, 'North America', 'NA', 'NA'      ],
    [ 4333, 'Oceania',       'OC', null      ],
    [ 4334, 'South America', 'SA', 'SA'      ]
  ]
});

Continent.prototype.isContinent = function() {
  return true;
};

<i>// This evaluates to true since the <b>enum</b> flag was turned on.  "NORTH_AMERICA" is derived from the name "North America"
// since the <b>name</b> field was marked as the <b>labelField</b> for the Continent collection.</i>
Continent.NORTH_AMERICA._id === 4332

<i>// The static data instances are also instances of the collection so methods and behaviors are available.</i>
Continent.NORTH_AMERICA.isContinent()
</code></pre>
   <h2>License</h2>

   <p>The project is licensed under <a href="http://www.apache.org/licenses/LICENSE-2.0.html">Apache License, Version 2.0</a>.

   <p>Patches are gladly accepted from their original author.  Along with any patches, please state that the patch is your original work and that you license the work to the Tyranid project under the Apache License, Version 2.0 open-source license.</p>

   <h2>Further Information</h2>

   <p>If you have any questions, please send email to <a href="mailto:info@tyranid.org">info@tyranid.org</a>.</p>
  </div>
