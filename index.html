---
layout: default
---

  <a href="https://github.com/tyranid-org/tyranid"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/652c5b9acfaddf3a9c326fa6bde407b87f7be0f4/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6f72616e67655f6666373630302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png"></a>

  </div>

  <div class="content">
   <h1>Tyranid.js</h1>
   <p><b>Tyranid</b> is a JavaScript-based, free, open-source, promise-based <b>metadata framework</b> for generically working with data.</p>
   <p>Tyranid currently works primarily with MongoDB and can act as an ODM for MongoDB.</p>

   <h2>Status</h2>

   <a href="https://www.npmjs.com/package/tyranid"><img src="https://img.shields.io/npm/v/tyranid.svg" alt="npm version"></a>
   <a href="http://www.apache.org/licenses/LICENSE-2.0.html"><img src="https://img.shields.io/npm/l/tyranid.svg" alt="npm version"></a>
   <a href="https://travis-ci.org/tyranid-org/tyranid"><img src="https://api.travis-ci.org/tyranid-org/tyranid.svg"></a>

   <p>The library is currently in its early stages and the API will likely change frequently until version 1.0 is reached.</p>

   <h2>Download</h2>

   <p>The repository is hosted at Github:</p>

   <pre><a href="https://github.com/tyranid-org/tyranid">https://github.com/tyranid-org/tyranid</a></pre>

   <p>NPM:</p>

   <pre>npm install tyranid</pre>

   <h2>Community</h2>

   <p>Tyranid has a Slack account for discussion and support for Tyranid.  Click the button for an invite:</p>

   <script async defer src="http://tyranid-slack.herokuapp.com/slackin.js"></script>

   <h2>Guide</h2>




   <h3>Setup</h3>

   <pre><code class="js">var mongodb = require('mongodb'),
    Tyr     = require('tyranid');

<i>// Initialize Tyranid with a <a href="http://mongodb.github.io/node-mongodb-native/">native MongoDB driver</a> instance.</i>
Tyr.config({
  db: await mongodb.MongoClient.connect(myDatabaseUrl)
});
<p>... import/require all types and schemas:</p>
<i>// Once all the types and schemas have been processed, invoke <b>Tyr.validate()</b> to have Tyranid link and validate
// all the references between the types and schemas.</i>
Tyr.validate();

<i>// Optionally, you can pass in array of directory and filename regex match to Tyranid config to load the models and</i>
<i>// validate all at once.</i>
Tyr.config({
  db: pmongo(myDatabaseUrl),
  validate: [{ dir: './app/models' }] <i>// all files in directory</i>
});
<p>... or, with fileMatch:</p>
Tyr.config({
  db: pmongo(myDatabaseUrl),
  validate: [{ dir: './app/models', fileMatch : '^tyr.*' }] <i>// all files in directory that start with 'tyr'</i>
});
</code></pre>




   <h3>Types</h3>
<p>You can define your own types.  Types can specify code to serialize to/from the browser, validation code, and so on.</p>
<pre><code class="js">new Tyr.Type({
  name: 'ssn',
  notes: 'Defines a U.S. Social Security Number',
  <i>// SSNs will not be sent down to the browser by default for security reasons.</i>
  <i>// client can also be a function... </i>
  <i>// --> client : function(value) { return this.security === 'low' } </i>
  <i>// this will pass 'ssn' to the client if the value of 'security' in the containing document is 'low'</i>
  client: false,
  validate: function(path, field, value) {
    if (!!value.match(/^\d{3}-\d{2}-\d{4}$/)) {
      return new Tyr.ValidationError(path, 'is not a valid SSN.');
    }
  }
});
</code></pre>




   <h3>Schemas</h3>

<pre><code class="js"><i>// Metadata describing nested structures can be either placed inline or defined separately.</i>
var RoleEntry = {
  is: 'object',
  fields: {
    network: { link: 'network' },
    role:    { link: 'role' }
  }
};

var User = new Tyr.Collection({
  <i>// Collections also have an id which is used to construct <b>universal ids</b> and other metadata purposes.</i>
  id: 'u00',
  name: 'user',
  dbName: 'users', <i>// defaults to value for "name"</i>
  fields: {
    <i>// Types like "email", "mongoid", "password", etc. are built in to Tyranid but can be overridden.</i>
    _id:        { is: 'mongoid' },
    userId:     { is: 'mongoid', label: 'User ID' },
    email:      { is: 'email' },
    <i>// Shorthand:  "'password'" is equivalent to "{ is: 'password' }"</i>
    password:   'password',
    <i>// <b>required: true</b> will make this field required during validation.</i>
    firstName:  { is: 'string', required: true },
    lastName:   { is: 'string' },
    canLogIn:   { is: 'boolean' },
    birthDate:  { is: 'date' },
    ssn:        { is: 'ssn' },
    <i>// "org" links to another collection "organization".  <b>is</b> does not need to be specified -- Tyranid will infer</i>
    <i>// it based on the data type of the _id field in "organization".  Tyranid will also validate the schema and ensure that</i>
    <i>// it knows what "organization" is and update the reference with the Organization instance.</i>
    org:        { link: 'organization',
                  <i>// <b>as</b> can be applied to fields or collections to give a human-readable name suitable for using in a UI.</i>
                  label: 'Organization'
                },
    inactive:   { is: 'boolean' },
    comments:   { is: 'string',
                  <i>// <b>help</b> contains user-facing documentation that could be used in, for example, a tool tip.</i>
                  help: 'Place any public comments you would like to make here.',
                  <i>// <b>note</b> contains internal, developer documentation.</i>
                  notes: 'Used for various notes that the user sets themselves.' },
    roles:      { is: 'array', of: _.cloneDeep(RoleEntry) }
  },
  <i>// Can optionally specify a field to act as this collection's primary key, defaulting to <b>_id</b>.</i>
  <i>// This field will be used for document retrieval, validation, and, most importantly, links and population.</i>
  <i>// Setting <b>defaultMatchIdOnInsert</b> will cause Tyranid to match <b>_id</b> to this field's value on</i>
  <i>// insert (instead of generating a new ObjectId).</i>
  primaryKey: { field: 'userId', defaultMatchIdOnInsert: true }
});

User.myStaticMethod = function() { ... };

User.prototype.fullName = function {
  return this.firstName + ' ' + this.lastName;
};

<i>// Tyranid can fetch collections by name.</i>
(Tyr.byName('user') instanceof Tyr.Collection) === true
</code></pre>

     <h4 id="mixinSchemas">Mixin Schemas</h4>
<p>Tyranid also supports <b>mixin schemas</b> via the <a href="collection#mixin"><u>Collection.mixin()</u></a> method
that can statically add metadata to an existing collection.  This is useful for extending built-in Tyranid collection
with additional metadata to suit your needs.</p>
</form>
The following adds a "westTotal" property to User:</p>
<pre><code class="js">User.mixin({
  def: {
    fields: {
      westTotal: { is: 'integer' }
    }
  }
});
</code></pre>
     <h4 id="dynamicSchemas">Dynamic Schemas</h4>
<p>Tyranid also supports <b>dynamic schemas</b> that can be added at runtime via storing metadata in the database.
Dynamic schemas differ from Mixin Schemas in that they are <i>conditionally applied</i> based on the match rules.</p>
<p>The following adds a "westTotal" property to User but only for users that belong to Organization 1:</p>
<pre><code class="js">Tyr.byName('tyrSchema').save({
  collection: User.id,
  match: {
    org: 1
  },
  type: Tyr.byName('tyrSchemaType').PARTIAL._id,
  def: {
    fields: {
      westTotal: { is: 'integer' }
    }
  }
});
</code></pre>
<p>You can get a list of fields that apply to a specific document using <b>fieldsFor</b>:</p>
<pre><code class="js">const fields = await User.fieldsFor({ org: 1 });
</code></pre>




    <h3>Finding & Saving</h3>
<pre><code class="js">var user = new User();
user.firstName = 'David';

<i>// Built-in document methods and properties start with $ to avoid collisions with actual document property names.
// (It is illegal to have properties that start with $ in MongoDB.)</i>
user.$save().then(function() {
  <i>// save is complete</i>
});

<i>// Document level update, but only saves the shallow properties of the object, if the properties are set in the object.</i>
user.$update().then(function() {
  <i>// update is complete</i>
});

<i>// Collection level update, same API as mongo shell update().</i>
User.update(query, update, opts).then(function() {
  <i>// update is complete</i>
});

<i>// <b>collection</b>.db is an instance of a <a href="http://mongodb.github.io/node-mongodb-native/">native MongoDB</a> collection for when it is easier to just work directly with mongo.</i>
User.db.find({ ... }).then(function(users) {
});

<i>// Similar to the previous line except that users are wrapped as User objects.</i>
User.find({ ... }).then(function(users) {
});

<i>// Returns a single user wrapped as a User object.  Parameters are the same as MongoDB's findOne() API.</i>
User.findOne({ ... }).then(function(users) {
});

<i>// Behaves the same as MongoDB's findAndModify() API.  If using <b>timestamps</b> and the <b>update</b> option, Tyranid will add in
// an <b>updatedAt</b> update as well.</i>
User.findAndModify({ ... }).then(function(users) {
});

<i>// Returns the user with ObjectId('AF8...123') wrapped as a User object.  <b>byId(id)</b> is a shortcut for
// User.findOne({ _id: id }).</i>
User.byId(ObjectId('AF8...123')).then(function(user) {
});

<i>// Same as User.db.remove()</i>
User.remove({ _id: id });
</code></pre>





    <h3 id="labels">Labels</h3>

<p>Labels can be defined for documents using the <u>labelField</u> option:</p>

<pre><code class="js">var Continent = new Tyr.Collection({
  <i>...</i>
  fields: {
    <i>...</i>
    <i>// <b>labelField</b> indicates that this field is the label value for this collection.</i>
    name:       { is: 'string', labelField: true },
    <i>...</i>
  }
});
</code></pre>

<p>Examples using labels are:</p>

<pre><code class="js"><i>// Finds the document in an emum collection where the label is equal to the given label.</i>
let country = Country.byLabel('Germany');

<i>// Returns the value of the label field for the document.  The following would output "Germany":</i>
Country.labelFor(country)

<i>// The same method is available on document instances as a dynamic property as well:</i>
country.$label
</code></pre>

<p>Collections and Fields also support a <b>label</b> property.  If no label is provided one will be generated from the <b>name</b>.</p>
<pre><code class="js">User.label                    <i>=> 'User'</i>
User.def.fields.userId.label  <i>=> 'User ID'</i>
User.def.fields.email.label   <i>=> 'Email'</i>
</code></pre>




    <h3>Fields</h3>
<pre><code class="js"><i>// Fields support a <b>name</b> property.</i>
User.def.fields.email.name <i>=> 'email'</i>

<i>// Fields also support a <b>path</b> property.</i>
User.def.fields.roles.def.of.def.fields.network.path <i>=> 'roles.network'</i>
</code></pre>




    <h3 id="links">Links</h3>

<p>Fields of type <u>link</u> support a <u>relate</u> property.  The valid values for relate are:</p>
<table>
  <thead>
    <tr><th>Value<th>Notes
  <tbody>
    <tr><td><u>associate</u><td>The default.  Indicates a regular associative link.
    <tr><td><u>owns</u><td>Indicates that the linked-to document is "owned" or "composed in" the linking document.
    <tr><td><u>ownedBy</u><td>Indicates that the linked-to document "owns" or "is composed of" the linking document.
</table>

<p>For example:</p>

<pre><code class="js">var Department = new Tyr.Collection({
  id: 'd00',
  name: 'department',
  fields: {
    <i>...</i>
    <i>// This ties departments to the lifecycle of their organization.</i>
    organization:   { link: 'organization', relate: 'ownedBy' },
    <i>...</i>
  }
});
</code></pre>

<p><u>link</u> Fields also support a <u>where</u> property.  For example:</p>

<pre><code class="js">var User = new Tyr.Collection({
  id : 'u00',
  name: 'user',
  fields: {
    <i>...</i>
    <i>// Managers have to be in the same organization as the user.</i>
    manager:   { link: 'user', where: { organizationId: $this.organizationId } },
    <i>...</i>
  }
});
</code></pre>

<p>Collections support a <a href="collection#links"><u>Collection.links()</u></a> method to search for incoming and outgoing links.</p>



    <h3 id="client">Client</h3>
<p>Tyranid will automatically generate collections, fields, and so on for use on the client based upon the server metadata.</p>
<p>Only collections that have <u>client: true</u> will have their metadata sent to the client.  By default collections are server-only.</p>
<p>Client-side Tyranid is enabled by the following two steps:</p>
<ol>
  <li>Initialize routing.  <u>express</u> is the instance returned by <u>express()</u>.  <u>auth</u> is a callback that will be placed ahead
    of all routes (you can do additional authorization in this function).
<pre><code class="js">Tyr.express(express, auth);</code></pre>
  <li>Import client-side code into your browser session:
<pre>&lt;script src="/api/tyranid">&lt;/script></pre>
</ol>

<p>The Tyranid namespace is available on the client as <u>window.Tyr</u>.</p>
<p style="width:904px;"><b class="client"></b>Methods, properties, and classes that are available on the client are identified in the documentation by the client tag:</p>

<p>Code will be transpiled to ES5 by Babel, so you can use ES2015 functionality in your client-side code.</p>
<p>Code generated will also by default be minified (controlled by the <u>minify</u> option in <a href="tyr#config"><u>Tyr.config()</u></a>).</p>



    <h3 id="computedProperties">Computed Properties</h3>
<p>Computed values can be created by specifying a <u>get</u> option on a property.  By default computed values will:
  <ol>
    <li>not be stored in the database unless the <u>db</u> property is set to true, and
    <li>not be sent down to the client with <u>toClient()</u> unless the <u>client</u> property is set to true.
  </ol>
</p>
<pre><code class="js">var User = new Tyr.Collection({
  <i>...</i>
  fields: {
    <i>...</i>
    firstName:  { is: 'string' },
    lastName:   { is: 'string' },
    fullName:   { is: 'string', get: function() { return this.firstName + ' ' + this.lastName; }, db: true, client: true },
    <i>...</i>
  }
});
</code></pre>
<p>By default <u>get</u> methods are isomorphic if <a href="#client">client-side functionality</a> is enabled.  If you want the function to only appear
on the server you can use <u>getServer</u> instead.  You can also optionally specify a client-specific version using <u>getClient</u>.

<h4>Set</h4>

<p><u>set</u>, <u>setClient</u>, <u>setServer</u> also exist to provide a programmatic setter for properties as well.</p>



    <h3 id="methods">Methods</h3>
<p>Tyranid supports defining methods in metadata.</p>

<pre><code class="js">var User = new Tyr.Collection({
  <i>...</i>
  methods: {
    <i>methodName</i>: {
      fn(<i>parameters</i>) { <i>...</i> },
    },
    <i>...</i>
  },
  <i>...</i>
});
</code></pre>

<p>By default <u>fn</u> methods are isomorphic if <a href="#client">client-side functionality</a> is enabled.  If you want the method to only appear
on the server you can use <u>fnServer</u> instead.  You can also optionally specify a client-specific version using <u>fnClient</u>.


    <h3 id="population">Population</h3>
<pre><code class="js"><i>// Tyranid can traverse links and provide join-like functionality.</i>
User.populate('org', users).then(function(users) {
  <i>// An <b>org$</b> property on each user will be added with an actual organization document.</i>
});

<i>// If your field that you are populating ends with "Id", the populated field will be the same name with the "Id" removed
// instead of a "$" appended.</i>
User.populate('orgId', users).then(function(users) {
  <i>// An <b>org</b> property on each user will be added with an actual organization document.</i>
});

<i>// If you leave off the second array of documents parameter to <b>populate()</b> it will return a curried version of itself
// that can be inserted into a find promise chain.</i>
User.find({ ... }).then(User.populate('org'));

<i>// You can also populate a single instance:</i>
user.$populate('org');

<i>// You can also pass in pathnames to populate.  Arrays will also be populated as well.</i>
user.$populate('roles.role');

<i>// You can also pass in an array of property names to populate.</i>
user.$populate([ 'org', 'roles.role' ]);
</code></pre>
    <h4 id="advancedPopulation">Advanced Population</h4>
<p>The advanced form of population allows you to perform nested populations and specify the projections of populations.</p>
<pre><code class="js"><i>// Population often uses an "$all" constant.  "Tyr.$all" is defined as "Tyr.$all = '$all'".</i>
var Tyr  = require('tyranid'),
    $all = Tyr.$all;

<i>// The following says to populate the <b>org</b> field and also populate the "_id", "name", and "network" properties from <b>role</b>.
// Additionally, the <b>network$</b> property on roles will also be populated, but only the names will be retrieved, not the _id's
// (or any other properties ... _id's are included by default in projections according to MongoDB conventions).</i>
user.$populate({ org: $all, 'roles.role': { name: 1, network: { _id: 0, name: 1 } } });

<i>// The following says to grab all the properties off of <b>role</b> and to also populate the <b>network</b> property.</i>
user.$populate({ 'roles.role': { $all: 1, network: $all } });

<i>// "$all: 1" can also be written "$all: $all".  If using ES6, this means it can be written as just "$all".
// For example the previous can be written as:</i>
user.$populate({ 'roles.role': { $all, network: $all } });
</code></pre>
<p>The values that can follow a property pathname are:</p>
<table>
 <tr><td style="width:70px">0</td><td><i>Means exclude this property.  Similar to MongoDB's projection.</i></td></tr>
 <tr><td>1</td><td><i>Means include this property.  Similar to MongoDB's projection.</i></td></tr>
 <tr><td>$all</td><td><i>Means to populate the field and grab all the properties.  Can only be specified on a link.</i></td></tr>
 <tr><td>{ <i>...</i> }</td><td><i>Recursively list properties to populate.  Can only be specified on a link.</i></td></tr>
</table>
<p>In general, population will not query the same document more than once.  If the document shows up in multiple places
with different projections all locations will contain the same document which will contain a superset of the projections.
This also means that population can be used to populate relationships with cycles.</p>
    <h4 id="denormalization">Denormalization</h4>
<p>Tyranid can also store populations when a document is saved or updated.  For example, this can be useful for cases where
you need a a few properties redundantly stored in a collection so you have more indexing options.</p>
<p>This capability shows up as a <b>denormal</b> option when defining a field.  For example, the following would store a
copy of the Organization's name field redundantly on the User collection.  Similar to how population would store populated
org data under a variable "org$", denormalized data will get stored as "org_".  In the following example, the org link would
be available as "user.org" while the denormalized name would be available as "user.org_.name".</p>
<pre><code class="js">var User = new Tyr.Collection({
  <i>...</i>
  fields: {
    <i>...</i>
    org:  { link: 'org', <b>denormal: { name: 1 }</b> },
    <i>...</i>
  }
});
</code></pre>




    <h3>Validation</h3>
<p>The following will run validations on the object and return an array of <a href="validationError">ValidationError</a>s:</p>
<pre><code class="js">user.$validate();
</code></pre>



    <h3 id="timestamps">Timestamps</h3>
<p>If you set <b>timestamps: true</b> when defining your collection then Tyranid will update the timestamps <b>createdAt</b> and
<b>updatedAt</b> when you create a new object using Tyranid's save() or insert() methods and it will update <b>updatedAt</b> when
you use Tyranid's update() methods.</p>
<pre><code class="js">var MyCollection = new Tyr.Collection({
  <i>...</i>
  timestamps: true,
  <i>...</i>
});
</code></pre>


    <h3 id="maps">Maps</h3>
<p>You can define your objects to be <i>maps</i> using the <a href="field#keys"><u>keys</u></a> and <a href="field#of"><u>of</u></a>
  field properties.</p>
<p>For example, the following defines a map of strings to integers.</p>
<pre><code class="js">{
  is: 'object',
  keys: 'string',
  of: 'integer'
}</code></pre>
<p>As another more complex example, the following defines a map of UIDs to objects.</p>
<pre><code class="js">{
  is: 'object',
  keys: {
    is: 'uid',
    of: [ 'user', 'group' ]
  },
  of: {
    is: 'array',
    of: 'string'
  }
}</code></pre>

<p>You can also combine <u>fields</u> and <u>keys</u>/<u>of</u> -- for example, the following defines a simple named array-like object of strings:</p>
<pre><code class="js">{
  is: 'object',
  fields: {
    name:   { is: 'string', fieldLabel: true },
    length: { is: 'integer' }
  },
  keys: 'number',
  of: 'string'
}</code></pre>


    <h3 id="uids">Universal IDs (UIDs)</h3>
<p>A UID is a string formed by concatenating a collection ID with a document ID.</p>
<p>Universal IDs are a way of polymorphically working with data.  For example, if you need to have an array of IDs
from multiple collections UIDs will let you do this.</p>
<pre><code class="js"><i>// Returns "u00AF8...123".  <b>u00</b> was specified as the collection ID for User.</i>
User.idToUid(ObjectId('AF8...123'))

<i>// returns "u00AF8...123" if user._id is ObjectId("AF8...123").</i>
user.$uid

<i>// returns { collection: User, id: ObjectId('AF8...123') }</i>
Tyr.parseUid('u00AF8...123')

<i>// Tyranid can fetch documents by UID without having to specify the collection for code that generically works with data.</i>
Tyr.byUid('u00AF8...123').then(function(user) {
  <i>// <b>user</b> is a User instance with mongo ID ObjectId('AF8...123').</i>
});

<i>// Tyranid also efficiently fetch an array of documents by UIDs as well:</i>
Tyr.byUids(['u00AF8...123', 'g00FDC...321', ...]).then(function(docs) {
  <i>...</i>
});
</code></pre>





    <h3>Browser Serialization</h3>
<pre><code class="js"><i>// Returns a <b>User</b> instance while also performing security checks, converting the _id to a MongoId, validating data,
// and so on.</i>
User.fromClient({ _id: 'AF8...123', firstName: 'Jack', ... })

<i>// Returns a "Plain Old JavaScript Object" (POJO)/JSON object that is suitable for sending down to client while also
// performing security checks.</i>
res.json(user.$toClient())

<i>// Translates an existing object to the client when the object is not an instance of <b>User</b> (i.e. came directly from Mongo).</i>
res.json(User.toClient(obj))
</code></pre>





    <h3 id="paths">Paths</h3>
<p><b>Paths</b> are a string-based syntax for referencing fields inside documents.  For example, the following structure:</p>
<pre><code class="js">{
  name: 'Jack',
  siblings: [
    { name: 'Jill' },
    { name: 'Joe' }
  ],
  address: {
    state: 'WI'
  }
}
</code></pre>
<p>has the following paths:</p>
<table>
  <tr><td>name</td><td>'Jack'</td></tr>
  <tr><td>siblings.0.name</td><td>'Jill'</td></tr>
  <tr><td>siblings._.name</td><td>'Jill', 'Joe'</td></tr>
  <tr><td>address.state</td><td>'WI'</td></tr>
</table>
</p>
<p>Collections contain a <a href="collection#paths"><u>paths</u></a> hash which make it easier to work with paths.</p>
    <h4>Arrays and Maps</h4>
<p>Arrays and <a href="index#maps">maps</a> have a special syntax.  When referring to the contents of an array or map in a generic sense, you use "<u>._</u>".
When referring to a particular element you use "<u>.<i>array index | map key</i></u>".</p>
<p>For example, <u>siblings</u> refers to an array, <u>siblings._</u> refers to the type of contents of the array (an object), and
<u>siblings._.name</u> refers to a specific property inside that object that is inside the array.</p>
<p>This array syntax can be simplified (i.e. <u>siblings._.name</u> => <u>siblings.name</u>) in certain circumstances,
for example when used inside MongoDB queries.  This is called a <i>simplified path</i> and is available as
<a href="field#spath"><u>Field.spath</u></a>.</p>
    <h4><a href="namePath">NamePath</a></h4>
<p>The <a href="collection#parsePath"><i>collection</i>.parsePath(<i>path</i>)</a> method can be used to create <a href="namePath">NamePath</a>
  objects which are useful for parsing paths.</p>
    <h4 id="pathLabels">Path Labels</h4>
<p><a href="field">Field</a>s have a <a href="field#def"><u>pathLabel</u></a> property which can be used to specify an abbreviated label a
field when it is used as part of a full-path label.  For example, if your path was <u>name.first</u>, you could set the <u>pathLabel</u> on <u>name</u>
to be blank and set the <u>pathLabel</u> to "First Name" on <u>name.first</u>.  This would cause <u>name.first</u> to have a full path label of "First Name"
instead of "Name First".  This property can also be used to set abbreviated names for path nodes so that the overall path label is not too long.</p>

</form>

</form>

    <h3 id="historical">Historical Data</h3>

    <p>Tyranid's Historical Data support modifies the built-in methods like <u>$save()</u> and so on to keep track of changes to documents so that historical
      values are kept.  The history of an object is stored on the document in a <a href="document#_history"><u>_history</u></a> property which contains an array of the changes.</p>
    <p>Historical data is enabled by specifying the <a href="collection#def"><u>historical</u></a> option on collections.</p>
    <p>Once it is enabled on a collection, you must also mark which fields should historical using the <a href="field#def"><u>historical</u></a> option on fields.</p>
    <p><i>Note that only top-level fields can be marked <u>historical</u></i> -- anything contained beneath a top-level field is automatically assumed to also be historical.</p>

    <h4>Workflow Example</h4>

<pre><code class="js">const update = User.fromClient(req.body),
        orig = await User.byId(update._id); // historical database reads will update the document's <a href="document#$orig">$orig</a> property

orig.$copy(update); // $copy() will not overwrite orig's $orig and _history properties
await orig.$save(); // $save() will diff orig.$orig and orig and update orig._history with a new snapshot entry
</code></pre>

    <p>Also see <a href="document#$replace"><u>$replace()</u></a> as an alternative to <a href="document#$copy"><u>$copy()</u></a>.

    <p>You can revert a document to older versions using the <a href="document#$asOf"><u>$asOf()</u></a> method:</p>

<pre><code class="js">doc = await User.byId(myId);

doc.$asOf(new Date('2016-05-03')); // revert doc to what it looked like on May 3, 2016.
</code></pre>
    <h4 style="color: red">Warning</h4>

    <p>If you bypass Tyranid calls and use the native MongoDB driver calls or modify database directly in the database, historical values will not be updated.</p>



    <h3 id="staticData">Static Data</h3>
<p>Tyranid supports efficiently modeling static data as well.  This is good for modeling enumerations and linking to them.
It also allows you to work with static and non-static data in an isomorphic way.</p>
<pre><code class="js">var Continent = new Tyr.Collection({
  id: 'c0a',
  name: 'continent',
  dbName: 'continents',
  <i>// This causes enumeration constants to be defined on the collection for each of the enumerated values.</i>
  enum: true,
  fields: {
    _id:        { is: 'integer' },
    <i>// <b>labelField</b> indicates that this field is the label value for this collection.</i>
    name:       { is: 'string', labelField: true },
    code:       { is: 'string' },
    altName:    { is: 'string', label: 'Alternate Name' }
  },
  values: [
    [ '_id', 'name',       'code', 'altName' ],

    [ 4328, 'Africa',        'AF', null      ],
    [ 4329, 'Antartica',     'AN', null      ],
    [ 4330, 'Asia',          'AS', null      ],
    [ 4331, 'Europe',        'EU', null      ],
    [ 4332, 'North America', 'NA', 'NA'      ],
    [ 4333, 'Oceania',       'OC', null      ],
    [ 4334, 'South America', 'SA', 'SA'      ]
  ]
});

Continent.prototype.isContinent = function() {
  return true;
};

<i>// This evaluates to true since the <b>enum</b> flag was turned on.  "NORTH_AMERICA" is derived from the name "North America"
// since the <b>name</b> field was marked as the <b>labelField</b> for the Continent collection.</i>
Continent.NORTH_AMERICA._id === 4332

<i>// The static data instances are also instances of the collection so methods and behaviors are available.</i>
Continent.NORTH_AMERICA.isContinent()
</code></pre>
  <p>If your static data has fields which link to another static collection, you can use labels in the values as the foreign key
to make the data more readable (they will be converted to ids when the collection is validated).</p>


    <h3 id="units">Units</h3>
<p>Units of Measurement are an important piece of metadata that Tyranid tracks.  In addition, Tyranid has a lot of
  knowledge around how to manipulate and do arithmetic with units.</p>
<p>You can associate units with a field using the <u>in</u> option:
<pre><code class="js">var Widget = new Tyr.Collection({
  id: 'w00',
  name: 'widget',
  <i>...</i>
  fields: {
    <i>...</i>
    <i>// <b>m^3</b> means <b>m<sup>3</sup></b> or <b>meters cubed</b> and indicates a volume tracked in meters.  Can also be written as "m3".</i>
    volume: { is: 'double', in: 'm^3' }
    <i>...</i>
  },
  <i>...</i>
});
</code></pre>
<p>The <a href="units"><u>Units</u></a> for fields are accessible on the <a href="fields"><u>Field</u></a> objects:</p>
<pre><code class="js">var units = Widget.fields.volume.in;</code></pre>
<p>You can also create your own <a href="units"><u>Units</u></a> instances using <a href="units#parse"><u>Units.parse()</u></a> or <a href="tyr#u"><u>Tyr.U</u></a>.
<pre><code class="js">const U = Tyr.U;

kg = U('kg');

<i>// The parsing functions can also be used as <b>tagged template strings</b>:</i>
kg = U`kg`;

<i>// Tyranid also supports composite units:</i>
mph = U`mi/h`;

<i>// Units can infer information about types and systems:</i>
U`m/s`.type.name === 'velocity'
U`m/s`.system.name === 'metric'
U`m/s2`.type.name === 'acceleration'
U`m*kg/s2`.type.name === 'force'
U`mP`.system.name === 'planck'
U`ft`.system.name === 'english'

<i>// Units can do conversions:</i>
U`in`.convert(12, U`ft`) === 1

<i>// Units can do addition and subtraction:</i>
U`in`.add(5, U`ft`, 1) === 17
U`in`.subtract(12, U`ft`, 1) === 0

<i>// Units can do multiplication, division, and inversions:</i>
U`m`.multiply(U`m*s-1`) === U`m2/s`
U`m`.divide(U`s2`) === U`m/s2`
U`m/s`.invert() === U`s/m`
</code></pre>

<p>See <a href="units">Units</a> and <a href="unit">Unit</a> for more information.</p>


   <h2>License</h2>

   <p>The project is licensed under <a href="http://www.apache.org/licenses/LICENSE-2.0.html">Apache License, Version 2.0</a>.

   <p>Patches are gladly accepted from their original author.  Along with any patches, please state that the patch is your original work and that you license the work to the Tyranid project under the Apache License, Version 2.0 open-source license.</p>

   <h2>Further Information</h2>

   <p>If you have any questions, please send email to <a href="mailto:info@tyranid.org">info@tyranid.org</a>.</p>
  </div>
