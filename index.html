<html>
 <head>
  <link href='http://fonts.googleapis.com/css?family=Megrim' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Metrophobic' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Lekton' rel='stylesheet' type='text/css'>
  <style>
 body { font-family: 'Metrophobic', arial, serif; }
 h1 {
  font-size:36px;
  font-family: 'Megrim', arial, serif;
  text-shadow: 2px 2px #bbb;
 }
 h2 {
  font-size:24px;
  font-family: 'Megrim', arial, serif;
 }
 pre {
   font-family: 'Lekton', courier, serif;
   color: #000;
 }
 pre i { color: #888; }
 pre b { color: #444; }
 .content {
   border:1px solid #000;
   padding:0 24px;
   background:#eee;
   margin:0 auto;
   width:1024px;
   -webkit-box-shadow:2px 2px 2px #aaa;
 }
  </style>
 </head>
 <body>
  <div class="content">
   <h1>Tyranid.js</h1>
   <p><b>Tyranid</b> is a free, open-source, promise-based ODM for MongoDB and JavaScript with a <b>strong emphasis on metadata</b>.</p>

   <h2>Status</h2>

   <p>The library is currently in its early stages and the API will likely change frequently until version 1.0 is reached.</p>

   <h2>Download</h2>

   <p>The repository is hosted at Github:</p>

   <pre><a href="https://github.com/tyranid-org/tyranid">https://github.com/tyranid-org/tyranid</a></pre>

   <p>NPM:</p>

   <pre>npm install tyranid</pre>

   <h2>Guide</h2>

   <h3>Example</h3>

   <pre>
var pmongo = require('promised-mongo'),
    Tyr    = require('tyranid');


<i>// Initialize Tyranid with a <a href="https://github.com/gordonmleigh/promised-mongo">promised-mongo</a> instance.</i>
Tyr.config({
  db: pmongo(myDatabaseUrl)
});

<i>// You can define your own types.  Types can specify code to serialize to/from the browser, validation code, and so on.</i>
new Tyr.Type({
  name: 'ssn',
  notes: 'Defines a U.S. Social Security Number',
  <i>// SSNs will not be sent down to the browser by default for security reasons.</i>
  client: false,
  validate: function(value) {
    return !!value.match(/^\d{3}-\d{2}-\d{4}$/);
  }
});

<i>// Metadata describing nested structures can be either placed inline or defined separately and reused.</i>
var RoleEntry = {
  is: 'object',
  fields: {
    network: { link: 'network' },
    role:    { link: 'role' }
  }
};

var User = new Tyr.Collection({
  <i>// Collections also have an id which is used to construct <b>universal ids</b> and other metadata purposes.</i>
  id: 'u00',                             
  name: 'user',
  dbName: 'users', <i>// defaults to value for "name"</i>
  fields: {
    <i>// Types like "email", "mongoid", "password", etc. are built in to Tyranid but can be overridden.</i>
    _id:        { is: 'mongoid' },
    email:      { is: 'email' },
    <i>// Shorthand:  "'password'" is equivalent to "{ is: 'password' }"</i>
    password:   'password',
    firstName:  { is: 'string' },
    lastName:   { is: 'string' },
    canLogIn:   { is: 'boolean' },
    birthDate:  { is: 'date' },
    ssn:        { is: 'ssn' },
    <i>// "org" links to another collection "organization".  <b>is</b> does not need to be specified -- Tyranid will infer
    // it based on the data type of the _id field in "organization".  Tyranid will also validate the schema and ensure that
    // it knows what "organization" is and update the reference with the Organization instance.</i>
    org:        { link: 'organization' },
    inactive:   { is: 'boolean' },
    comments:   { is: 'string',
                  <i>// <b>help</b> contains user-facing documentation that could be used in, for example, a tool tip.</i>
                  help: 'Place any public comments you would like to make here.',
                  <i>// <b>notes</b> contains internal, developer documentation.</i>
                  notes: 'Used for various notes that the user sets themselves.' },
    roles:      { is: 'array', of: RoleEntry }
  }
});

User.myStaticMethod = function() { ... };

User.prototype.fullName = function {
  return this.firstName + ' ' + this.lastName;
};

var user = new User();
user.firstName = 'David';

<i>// Built-in document methods start with $ to avoid collisions with actual document property names.</i>
user.$save();

<i>// returns "u00AF8...123" if _id is "AF8...123".  Universal IDs are a way of polymorphically working with data.
// For example, if you need to have an array of IDs from multiple collections UIDs will let you do this.</i>
user.$uid()

<i>// <b>collection</b>.db is an instance of a <a href="https://github.com/gordonmleigh/promised-mongo">promised-mongo</a> collection for when it is easier to just work directly with mongo.</i>
User.db.find({ ... }).then(function(users) {
});

<i>// Similar to the previous line except that users are wrapped as User objects.</i>
User.find({ ... }).then(function(users) {
});

<i>// Returns a <b>User</b> instance while also performing security checks, converting the _id to a MongoId, validating data,
// and so on.</i>
User.fromClient({ _id: 'AF8...123', firstName: 'Jack', ... })

<i>// Returns a "Plain Old JavaScript Object" (POJO)/JSON object that is suitable for sending down to client while also
// performing security checks.</i>
res.json(user.toClient())

<i>// Translates an existing object to the client when the object is not an instance of <b>User</b> (i.e. came directly from Mongo).</i>
res.json(User.toClient(obj))

<i>// Tyranid supports efficiently modeling static data as well.  This is good for modeling enumerations and linking to them.
// It also allows you to work with static and non-static data in an isomorphic way.</i>
var Continent = new Tyr.Collection({
  name: 'continent',
  dbName: 'continents',
  <i>// This causes enumeration constants to be defined on the collection for each of the enumerated values.</i>
  enum: true,
  fields: {
    _id:        { is: 'integer' },
    <i>// <b>label</b> indicates that this field is the label value for this collection.</i>
    name:       { is: 'string', label: true },
    code:       { is: 'string' },
    pcmName:    { is: 'string' }
  },
  values: [
    [ '_id', 'name',       'code', 'pcmName' ],

    [ 4328, 'Africa',        'AF', 'Africa'  ],
    [ 4329, 'Antartica',     'AN', null      ],
    [ 4330, 'Asia',          'AS', 'Europe'  ],
    [ 4331, 'Europe',        'EU', 'Europe'  ],
    [ 4332, 'North America', 'NA', 'NA'      ],
    [ 4333, 'Oceania',       'OC', 'Oceania' ],
    [ 4334, 'South America', 'SA', 'SA'      ]
  ]
});

Continent.prototype.isContinent = function() {
  return true;
}

<i>// This evaluates to true since the <b>enum</b> flag was turned on.</i>
Continent.NORTH_AMERICA._id === 4332;

<i>// The static data instances are also instances of the collection so methods and behaviors are available.</i>
Continent.NORTH_AMERICA.isContinent();
   </pre>

   <h2>License</h2>

   <p>The project is licensed under <a href="http://www.apache.org/licenses/LICENSE-2.0.html">Apache License, Version 2.0</a>.

   <p>Patches are gladly accepted from their original author.  Along with any patches, please state that the patch is your original work and that you license the work to the Tyranid project under the Apache License, Version 2.0 open-source license.</p>
 
   <h2>Further Information</h2>

   <p>If you have any questions, please send email to <a href="mailto:info@tyranid.org">info@tyranid.org</a>.</p>
  </div>
 </body>
</html>
