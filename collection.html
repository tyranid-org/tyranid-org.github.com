---
layout: default
---

  <div class="content">
    <h1>Collection <span class="extends">mixins <a href="component">Component</a></span></h1>

    <article id="options">
      <span class="sig">Options</span>
      <p>A lot of <u>Collection</u> methods take an <u>options</u> parameter.  The options available are:</p>

       <table class="def">
         <thead>
           <tr><th>Option<th>Type<th>Notes
         <tbody>
           <tr><td>{</td>
           <tr><td colspan="3" class="subtitle">Query (<u>find*()</u>, <u>update()</u>, <u>remove()</u>)</td>
           <tr><td>  query:<td>MongoDB query<td>The standard MongoDB-style query object.
           <tr><td colspan="3" class="subtitle">Projection & Population (<u>find*()</u>, <u>by*()</u>)</td>
           <tr><td>  fields:<td>MongoDB fields<td>The standard MongoDB-style fields object that specifies the projection.  Also supports <a href="/#projection">extended projection</a> syntax.
           <tr><td>  populate:<td><a href="#populationFields">Population Fields</a><td>The population fields to populate.
           <tr><td>  asOf:<td>date<td>Indicates that any <a href="/#historical">historical</a> documents (including populated documents) should be <a href="document#$asOf"><u>$asOf()</u></a>'d the given date.
           <tr><td colspan="3" class="subtitle">Windowing (<u>find()</u>, <u>findAll()</u>)</td>
           <tr><td>  limit:<td><u>integer</u><td>The maximum number of documents to retrieve.
           <tr><td>  skip:<td><u>integer</u><td>The number of documents to skip.
           <tr><td>  count:<td><u>boolean</u><td>If set on <u>findAll()</u> calls then the returned documents array will have a <u>count</u> property indicating the total number of
             documents matching the query (ignoring any <u>skip</u> and <u>limit</u>). See <a href="index#counting">Counting</a>.
           <tr><td colspan="3" class="subtitle">Sorting (<u>find()</u>, <u>findAll()</u>, <u>byIds()</u>, <u>byUids()</u>)</td>
           <tr><td>  sort:<td>MongoDB sort<td>The standard MongoDB-style sort object.
           <tr><td colspan="3" class="subtitle">Parallel Arrays (<u>byIds()</u>, <u>byUids()</u>)</td>
           <tr><td>  parallel:<td>boolean<td>If true, then the returning array will be parallel to the input array of IDs/UIDs.
           <tr><td colspan="3" class="subtitle">Deletions (<u>remove()</u>)</td>
           <tr><td>  justOne:<td>boolean<td>Whether to remove at most one document.
           <tr><td colspan="3" class="subtitle">Updates (<u>update()</u>, <b>but NOT</b> <u>$update()</u> or <u>updateDoc()</u>)</td>
           <tr><td>  update:<td>MongoDB update<td>The standard MongoDB-style update object.
             'insert' for <i>inserts</i>, etc.) but you can override it with this option.
           <tr><td colspan="3" class="subtitle"><a href="/#historical">Historical</a> (<i>most saving/updating methods</i>)</td>
           <tr><td>  author:<td>UID | <a href="document">Document</a><td>The author of the change that should be recorded in the historical snapshot.  If <u>author</u> is not specified
             but <u>auth</u> is, and <u>auth</u> is a <a href="document">Document</a>, then its UID will be used instead.</td>
           <tr><td>  comment:<td>string<td>A comment to record along with the historical update.</td>
           <tr><td>  historical:<td>boolean<td>Normally historical-unsafe methods log a warning if you use them with historical collections.  If you set historical to false you can suppress
            the warning indicating that you know what you are doing.  Additionally, if this flag is passed on an operation that does support historical operations, this option will
            suppress updating the history -- use with caution.</td>
           <tr><td colspan="3" class="subtitle">Timestamps (<i>most saving/updating methods</i>)</td>
           <tr><td>  timestamps:<td>boolean<td>Indicates if <a href="/#timestamps">timestamps</a> should be updated.  Defaults to the <a href="collection#def"><u>timestamps</u></a>
             setting on the collection.</td>
           <tr><td colspan="3" class="subtitle">Security (<i>most methods</i>)</td>
           <tr><td>  auth:<td>Auth Object<td>An authorization object (a user, group, role, etc.) to pass to a <a href="secure">Secure</a> plug-in.  Can also be "true" to auto-detect the current user.
           <tr><td>  perm:<td>string<td>The permission to use when an <u>auth</u> object is specified.  Usually <u>perm</u> is inferred ('view' for <i>finds</i>, 'delete' for <i>removes</i>, ...)
           <tr><td colspan="3" class="subtitle">Post-processing (<i>toClient()/$toClient()</i>)</td>
           <tr><td>  post:<td>opts => void<td>This provides a hook to perform any post-processing on the resulting document.  <u>this</u> is bound to the current document when this function is invoked.
             Note that this function is also invoked for any embedded documents as well (in this case <u>this</u> will be bound to the specific embedded document), so your function should be
             prepared to deal with potentially different types of data.</td>
           <tr><td colspan="3" class="subtitle">Plain 'ole JavaScript Object (POJO) conversion (<i>find*()/by*()</i>)</td>
           <tr><td>  plain:<td>opts => void<td>This indicates that returned documents should be raw POJO objects, not <a href="document">Document</a> instances.
           <tr><td>}</td>
       </table>

       <p>Not all options are supported by all methods.  For example, <u>findOne()</u> uses a <u>limit</u> of 1 and <u>Tyr.byUid()</u> does not support the <u>query</u> option.</p>
    </article>

    <article id="populationFields">
      <span class="sig">Population Fields</span>
      <p>A population fields definition can take one of the following three forms:
        <ul>
         <li>string -- the name of a field to populate.
         <li>string[] -- an array of names of fields to populate.
         <li>object -- object population syntax (<a href="/#advancedPopulation">Advanced Population</a> syntax).
        </ul>
      </p>
    </article>

    <h2>instance</h2>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <b class="async"></b>
       <span class="sig">byId(id: <i>id type</i>, options: <a href="#options">options object</a>): <a href="document">Document</a></span>
       <p>This retrieves a document by its id.</p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="async"></b>
       <span class="sig">byIds(ids: <i>id type</i>[], options: <a href="#options">options object</a>): <a href="document">Document</a>[]</span>
       <p>This retrieves a list of documents by their ids.</p>
       <p><b>The returned array is <i>parallel</i> to the given <u>ids</u> array if the <u>parallel</u> option is passed as in options.</b>
         If the same id shows up multiple times in the input query, then the returned array will also have multiple instances, but the
         instances will be shared.  If a given id does not exist in the database, then the corresponding entry will still be present, but
         it will contain <u>null</u>.</p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <b class="async"></b>
       <span class="sig">byLabel(label: string): <a href="document">Document</a></span>
       <p>This retrieves the first document it finds matching the given <u>label</u> using a case-insensitive search.</p>
     </article>

     <article id="cache">
       <b class="method"></b>
       <b class="client"></b>
       <span class="sig">cache(document: <a href="document">Document</a> | object): <a href="document">Document</a></span>
       <p>This method can be used to manually cache a document into the local Tyranid offline cache.</p>
       <p>This can be useful for when a document
         comes back from a non-Tyranid server API call and you want to inform Tyranid about the updated document.</p>
       <p>If Tyranid already had a local copy of the document then the existing document will be updated with the new information and the
         existing document will be returned.</p>
     </article>

     <article id="canInsert">
       <b class="method"></b>
       <b class="server"></b>
       <b class="async"></b>
       <span class="sig">canInsert(query: <i>MongoDB Query</i>, perm: string, auth: authObject): <i>MongoDB Query</i> | boolean</span>
       <p>If a <a href="secure"><u>Secure</u></a> component is registered with Tyranid, this method will be used to determine if a document can
         be inserted into a collection relative to the <u>authObject</u> (usually an instance of a user document).</p>
       <p>Most Tyranid insert and save use <u>canInsert()</u> internally when an <u>auth</u> option is used and end-users will not normally need to
         directly use this method.</p>
     </article>

     <article id="count">
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <b class="async"></b>
       <span class="sig">count(<i>options</i>: <a href="#options">options object</a>): number</span>
       <p>This returns a count of the documents that match the given <u>opts.query</u>.
       <p>See also <a href="index#counting">Counting</a> and also <a href="#exists">exists()</a>.
     </article>

     <article>
      <b class="property"></b>
      <b class="server"></b>
      <span class="sig">db: <a href="http://mongodb.github.io/node-mongodb-native/2.1/api/Collection">native MongoDB Collection</a></span>

      <p>This contains a reference to the underlying native MongoDB <u>Collection</u> instance.</p>
     </article>

     <article id="def">
       <b class="property"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">def</span>
       <p>This defines the structure of a collection and is the argument that is passed into the Collection constructor.</p>
       <table class="def">
<thead>
  <tr><th>Object Structure<th>Type<th>Default<th>Notes
</thead>
<tr><td>{</td>
<tr><td>  id:<td>string<td><i>required</i><td>3 character alphanumeric code, must be unique, see <a href="/#uids">UIDs</a>.
<tr><td>  name:<td>string<td><i>required</i>
<tr><td>  dbName:<td>string<td><i>name</i></td>
<tr><td>  server:<td>string<td><i>default server</i><td>The server to use with this collection -- see<br><u>Tyr.config({ servers: ... })</u>.</td>
<tr><td>  label:<td>string<td>labelify(<i>name</i>)<td>The human-readable <a href="/#labels">label</a> for this collection.
<tr><td>  indexes:<td>array<td><i>none</i><td>If present contains an array of index definitions in the format specified by the <a href="https://docs.mongodb.com/manual/reference/command/createIndexes/">MongoDB createIndexes command</a></td>
<tr><td>  help:<td>string<td>none<td>Contains brief user-facing documentation about this collection.
<tr><td>  historical:<td>boolean<td>none<td>Indicates if this collection should have <a href="/#historical">historical</a> data support.
<tr><td>  note:<td>string<td>none<td>Contains developer-facing documentation about this collection (only visible in the Tyranid console).
<tr><td>  enum:<td>boolean<td>false<td>Generates <a href="/#staticData">enumeration</a> support for this collection.
<tr><td>  internal:<td>boolean<td>false<td>Indicates that this is a collection used internally by Tyranid.
<tr><td>  generated:<td>boolean<td>false<td>Indicates that this is a collection was generated automatically.
<tr><td>  client:<td>boolean<td>true<td>If this is false, client-side classes for this collection will not be generated.
<tr><td>  primaryKey: {<td><td>none
<tr><td>    field:<td><i>fieldName</i><td><i>required</i>
<tr><td>    defaultMatchIdOnInsert:<td>boolean<td>false
<tr><td>  },</td>
<tr><td>  timestamps:<td>boolean<td>false<td>Enables <a href="/#timestamps">timestamps</a> on this collection.
<tr><td>  <span>express: {
<tr><td>    rest:<td>boolean<td>false<td>Activates all REST API endpoints.</td>
<tr><td>    get:<td>boolean<td>false
<tr><td>    post:<td>boolean<td>false
<tr><td>    put:<td>boolean<td>false
<tr><td>  },</span></td>
<tr><td>  fields: {</td>
<tr><td>    <i>fieldName</i>:<td><a href="field#def">Field Def</a></td>
<tr><td>    <i>...</i></td>
<tr><td>  },</td>
<tr><td>  methods: {<td><td><td>Define <a href="document">Document</a> methods for this collection.  See <a href="/#methods">Methods</a>.
<tr><td>    <i>methodName</i>: {</td>
<tr><td>      fn(<i>method parameters</i>) { <i>...</i> }<td>function<td>none<td>A single isomorphic function for both client and server.</td>
<tr><td>      fnClient(<i>method parameters</i>) { <i>...</i> }<td>function<td>none<td>The function to use on the client.</td>
<tr><td>      fnServer(<i>method parameters</i>) { <i>...</i> }<td>function<td>none<td>The function to use on the server.</td>
<tr><td>    },</td>
<tr><td>    <i>...</i></td>
<tr><td>  },</td>
<tr><td>  values: {<td><td>none<td>This allows you to define <a href="/#staticData">static data</a> in a tabular format.</td>
<tr><td>    [ '_id', '<i>fieldName1</i>', ... ],<td><td><td>The first row is a header row which contains field names.</td>
<tr><td>    [ <i>id1</i>,   <i>value1</i>,       ... ],<td><td><td>The following rows are data rows.</td>
<tr><td>    ...</td>
<tr><td>  }</td>
<tr><td>  projections: {</td>
<tr><td>    <i>projectionName</i>:<td><i>MongoDB-style projection</i><td><td>Define standard projections.  See <a href="/#projection">projections</a>.</td>
<tr><td>    <i>...</i></td>
<tr><td>  },</td>
<tr><td>  fromClient:<td>opts => void<td><td>Specifies a <a href="collection#fromClient"><u><i>Collection</i>.fromClient()</u></a> post-processing hook that will be applied for this collection.</p>
<tr><td>  toClient:<td>opts => void<td><td>Specifies a <a href="collection#toClient"><u><i>Collection</i>.toClient()</u></a> post-processing hook that will be applied for this collection.</p>
<tr><td>  linkEvents:<td><a href="event#linkHandlers">object</a><td>none<td>Defines <a href="event#linkHandlers">link event handlers</a> recommended or required by this collection.  See <a href="event">Event</a> for more information.</p>
<tr><td>}</td>
</table>
     </article>

     <article id="exists">
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <b class="async"></b>
       <span class="sig">exists(<i>options</i>: <a href="#options">options object</a>): boolean</span>
       <p>This returns true if any documents that match the given <u>opts.query</u> (and permission checks).
       <p>See also <a href="#count">count()</a>.
     </article>

     <article>
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">fake({ n, schemaOpts, seed } = {}): n > 1 ? <a href="document">Document</a>[] : <a href="document">Document</a></span>
       <p>This creates <u>n</u> fake documents (default is 1) for fields matching <u>schemaOpts</u> using the given <u>seed</u>.</p>
     </article>

     <article id="fields">
       <b class="property"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">fields: { <i>field name</a></i>: <a href="field">Field</a> }</span>
       <p>This is a parallel hash to <u>def.fields</u> that contains the generated <a href="field"><u>Field</u></a> objects.</p>
     </article>

     <article id="fire">
       <b class="method"></b>
       <b class="server"></b>
       <b class="async"></b>
       <span class="sig">fire(event: <a href="event#eventObject">Event</a>): void</span>
       <p>This method fires off an event that is bound to this collection.</p>
       <pre><i>MyCollection</i>.fire({ ... });</pre>
       <p>is shorthand for:</p>
       <pre>Tyr.Event.fire({ collection: <i>MyCollection</i>, ... });</pre>
       <p>See <a href="event#fire"><u>Event.fire()</u></a> for more information.</p>
     </article>
     <h2 id="eventObject">instance</h2>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">fieldsBy(filter: Field => boolean): <a href="field">Field</a>[]</span>
       <p>This returns an array of <a href="field"</a>Field</a>s that match the given filter.<p>
       <p>For example, following returns a list of all of the fields in the User collection that are of type string.</p>
       <pre>User.fieldsBy(field => field.def.is.def.name === 'string')</pre>
     </article>

     <article>
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">fieldsFor(obj): <a href="field">Field</a>[]</span>
       <p>This is similar to <u>def.fields</u> except that it also returns all fields from <a href="/#dynamicSchemas">Dynamic Schemas</a> as well.</p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="async"></b>
       <span class="sig">find(options: <a href="#options">options object</a>): Cursor&lt;<a href="document">Document</a>&gt;</span>
       <p>
        This behaves like the <a href="http://mongodb.github.io/node-mongodb-native/">native MongoDB driver</a>'s <u>find()</u> method with the addition that results are wrapped in this
        collection's document type.
       </p>
     </article>

     <article id="findAll">
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <b class="async"></b>
       <span class="sig">findAll(options: <a href="#options">options object</a>): <a href="document">Document</a>[]</span>
       <p>This behaves like <a href="#find"><u>find()</u></a> except that it returns an array of <a href="document">Document</a>s instead of a cursor.</p>
       <p><u>findAll()</u> also supports the <a href="index#counting"><u>count</u></a> option.</p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <b class="async"></b>
       <span class="sig">findOne(options: <a href="#options">options object</a>): <a href="document">Document</a></span>
       <p>
        This behaves like <a href="http://mongodb.github.io/node-mongodb-native">native MongoDB</a>'s <u>findOne()</u> method except that the results are wrapped in this collection's
        document type.  You can also just pass in a single options object and specify the query on the options object directory.
       </p>
     </article>

     <article id="findAndModify">
       <b class="method"></b>
       <b class="server"></b>
       <b class="async"></b>
       <span class="sig">findAndModify(options: <a href="#options">options object</a>)</span>
       <p>
        This behaves like <a href="http://mongodb.github.io/node-mongodb-native/">native MongoDB</a>'s <u>findAndModify()</u> method except the options are passed in a single
        <a href="#options">options</a> object and the results are wrapped in this collection's document type.
       </p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">fromClient(doc: object, <a href="/#paths">path</a>: string?, opts: object?): <a href="document">Document</a></span>
       <p>
        This creates a new document instance out of a POJO.  Values are copied by reference (not deep-cloned!).
      </p>
      <p>
        If this collection has a <u>fromClient</u> hook registered it will be invoked.  If Tyranid is itself calling <u>fromClient()</u>
        (for example, via automatically-generated client calls), it will pass in the express request object in the options objects available
        as <u>options.req</u>.
      </p>
     </article>

     <article id="fromClientQuery">
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">fromClientQuery(query: object): object</span>
       <p>This converts a MongoDB-style query created on the client into one suitable to be used on the server.  For example:</p>
       <table>
         <tr><th>Client<th>Server
         <tr>
           <td><pre>{
  isbn: {
    $in: [
      '5614c2f00000000000000000',
      '5614c2f00000000000000001'
    ]
  }
}</pre><td><pre>{
  isbn: {
    $in: [
      ObjectId('5614c2f00000000000000000'),
      ObjectId('5614c2f00000000000000001')
    ]
  }
}</pre>
       </table>
     </article>

     <article id="id">
       <b class="property"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">id: string</span>
       <p>This contains the 3-character ID for the collection.</p>
     </article>

     <article id="idToLabel">
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">idToLabel(id: <i>id type</i>): string</span>
       <p>This returns the label for the specified <u>id</u>.</p>
       <p>This method will return an empty string if it is given a non-truthy <u>id</u> (i.e. if the id is not defined).</p>
     </article>

     <article id="idToUid">
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">idToUid(id: <i>id type</i>): <a href="/#uids">UID string</a></span>
       <p>
        This generates a <a href="/#uids">UID</a> from an id.
       </p>
     </article>

     <article>
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">insert(doc: <a href="document">Document</a> | object | <a href="document">Document</a>[] | object[])</span>
       <p>
        This behaves like <a href="http://mongodb.github.io/node-mongodb-native/">native MongoDB</a>'s <u>insert()</u> method but also
        does things like <a href="/#timestamps">timestamps</a>, <a href="/#denormalization">denormalization</a>, and so on.
       </p>
       <p>If you pass in an array, then the array of documents/objects will be inserted in bulk.</p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">isStatic(): boolean</span>
       <p>
        This returns true if the collection's data is defined statically in its def.values field.  Enumerations are a common example
        of static collections.
       </p>
     </article>

     <article id="isUid">
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">isUid(uid: <a href="/#uids">UID string</a>): boolean</span>
       <p>This returns true if the given UID refers to a document in this collection.</p>
     </article>

     <article>
       <b class="property"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">label: string</span>
       <p>This returns a label, or display name, for the collection itself.</p>
     </article>

     <article>
       <b class="property"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">labelField: <a href="field">Field</a></span>
       <p>If this collection has a field that is marked with <u>labelField</u> this returns the that field.</p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">labelFor(doc: <a href="document">Document</a> | object)</span>
       <p>This returns the label for the specified document.  If <b>doc</b> is a Document, then this is equivalent to <u>doc.$label</u>.
        This method is mostly useful for when you have a raw object that you want to get the label for.</p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <b class="async"></b>
       <span class="sig">labels(text: string): { _id: <i>id type</i>, <i>label field</i>: string }[]</span><br>
       <span class="sig">labels(ids: string[]): { _id: <i>id type</i>, <i>label field</i>: string }[]</span>
       <p>This generates a list of label objects that can be used to populate a typeahead dropdown.</p>
       <p>Generally prefer to use <a href="field#labels"><u>Field.labels()</u></a> over this as it can take advantage of the <u>where</u> property on link fields.</p>
     </article>

     <article id="links">
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">links(opts): <a href="field">Field</a>[]</span>
       <p>This generates a list of links between this collection and other collections.  By default this will find both outgoing links <i>and incoming links</i>
        from other collections to this one.</p>
       <p><u>opts</u> are:
       <ul>
         <li><u>relate</u>:
           <table>
             <thead>
               <tr><th>Value<th>Notes
             <tbody>
               <tr><td>'associate'<td>Only look at "associate" links.
               <tr><td>'owns'<td>Only look at "owns" links.
               <tr><td>'ownedBy'<td>Only look at "ownedBy" links.
           </table>
         <li><u>direction</u>:
           <table>
             <thead>
               <tr><th>Value<th>Notes
             <tbody>
               <tr><td>'incoming'<td>Only look at incoming links.
               <tr><td>'outgoing'<td>Only look at outgoing links.
           </table>
       </ul>
     </article>

     <article id="mixin">
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">mixin(def: <a href="#def">def Object</a>): void</span>
       <p>This allows you to mixin additional metadata (like additional fields) to an existing collection.  This is useful for adding additional metadata to built-in
         Tyranid or third-party collections.  See <a href="index#mixinSchemas">Mixins</a> for more information.</p>
     </article>

     <article id="on">
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">on(opts: object): () => void</span>
       <p>Lets you add an event handler on this collection.  See <a href="event#on"><u>event handlers</u></a> for more information on how events work in Tyranid.</p>
       <p><u>opts</u> can contain the following:</p>
       <table class="def">
         <thead>
           <tr><th>Option<th>Type<th>Notes
         <tbody>
           <tr><td>{</td>
           <tr><td>  type:<td>string<td>The type of the event.  See <a href="event#types">event types</a>.
           <tr><td>  handler:<td>async? <a href="event">Event</a> => boolean<td>This is the handler that will be called when the event is triggered.
           <tr><td>  when:<td>'pre' | 'post'<td>Whether the handler should be invoked before or after the event takes place.  Not all event types support both <u>pre</u> and <u>post</u>.
           <tr><td>}</td>
       </table>
     </article>

     <article id="parsePath">
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">parsePath(text: string): <a href="namePath">NamePath</a></span>
       <p>This parses a <a href="/#paths">path</a> into a <a href="namePath">NamePath</a> object.</p>
     </article>

     <article id="paths">
       <b class="property"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">paths: { <i><a href="/#paths">field path name</a></i>: <a href="field">Field</a> }</span>
       <p>This is a hash of all the fields inside a collection by their <a href="/#paths">path names</a>.  Paths are often more
        convenient to work with than recursively walking the def.fields.* structure.</p>
       <p>Note that unlike <a href="collection#fields"><u>Collection.fields</u></a> which just has the top-level fields, <u>paths</u> contains
        nested fields as well.</p>
     </article>

     <article id="populate">
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">populate(fields: <a href="#populationFields">Population Fields</a>, documents: <a href="document">Document</a> | <a href="document">Document</a>[], <a href="/#denormalization">denormal</a>: boolean)</span>
      <p>
        If <b>documents</b> is not provided, this function will return a curried version of this function that takes a single array
        of documents.  This allows populate to be fed into a promise chain.
      </p>
      <p>
        See <a href="/#population">Population</a> for more information and examples.
      </p>
     </article>

     <article id="pull">
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">pull(id: <i>id type</i>, <a href="/#paths">path</a>: string, predicate: any => boolean, options: <a href="#options">options object</a>?)</span>
      <p>This method assumes that <u>path</u> points to an array inside the document.  This method will remove all elements of the array that match the
        <u>predicate</u> function.</p>
      <p>For example:</p>
<pre><code class="js">User.pull(myId, 'name.suffices', suffix => suffix === 'Sr');
</code></pre>
      <p>This method will also retain historical information for <a href="/#historical">historical documents</a>.
     </article>

     <article id="push">
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">push(id: <i>id type</i>, <a href="/#paths">path</a>: string, value: any, options: <a href="#options">options object</a>?)</span>
      <p>This is a shortcut for:</p>
      <quote><u><i>collection</i>.update({ _id: id }, { $push: { [path]: value } })</u></quote>
      <p>However, this method will also atomically retain historical information for <a href="/#historical">historical documents</a>.
     </article>

     <article id="references">
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">references(opts): <a href="document">Document</a>[]</span>
       <p>This finds all the documents that link to the given id(s) in the database.  This will also find any <a href="/#uids">UID</a> references.</p>
       <table class="def">
<thead>
  <tr><th>Option<th>Type<th>Notes
</thead>
<tr><td>{</td>
<tr><td>  id:<td><i>id type</i> | <i>id type</i>[]<td>Contains an id or an array of ids to find references to.
<tr><td>  ids:<td><i>id type</i> | <i>id type</i>[]<td>Alias for "id"
<tr><td>  idsOnly:<td>boolean<td>By default the full documents are returned.  If this is returned, the documents only contain their id.
<tr><td>  exclude:<td><a href="collection">Collection</a> | <a href="collection">Collection</a>[]<td>Contains a list of collections to exclude from the search.
<tr><td>}</td>
</table>
     </article>

     <article id="remove">
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <b class="async"></b>
       <span class="sig">remove(id: <i>id type</i> | query: object, justOne: boolean?)</span>
       <p>
        This behaves like <a href="http://mongodb.github.io/node-mongodb-native/">native MongoDB</a>'s <u>remove()</u> method.
       </p>
     </article>

     <article id="save">
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <b class="async"></b>
       <span class="sig">save(doc: <a href="document">Document</a> | object | <a href="document">Document</a>[] | object[]): <a href="document">Document</a></span>
       <p>
         This method will either update or insert the object based on whether it has an _id.
       </p>
       <p>
         When updating, the entire document is <b>replaced</b>.  Use <a href="document#updateDoc">updateDoc()</a> to only modify updated fields.
       </p>
     </article>

     <article id="secureQuery">
       <b class="method"></b>
       <b class="server"></b>
       <b class="async"></b>
       <span class="sig">secureQuery(query: <i>MongoDB Query</i>, perm: string, auth: authObject): <i>MongoDB Query</i> | boolean</span>
       <p>If a <a href="secure"><u>Secure</u></a> component is registered with Tyranid, this method will update the query with security restrictions
         the secure component mandates relative to the <u>authObject</u> (usually an instance of a user document).</p>
       <p><b>Warning:  This method will return <u>false</u> if the query is categorically rejected so it is important that the results of this
         are not immediately passed into a subsequent query.  You need to look at the result and if it is <u>false</u> short-circuit the query.</b>
         See <a href="collection#secureFindQuery"><u>secureFindQuery()</u></a>.</p>
       <p>Most Tyranid methods use <u>secureQuery</u> internally when an <u>auth</u> option is used and end-users will not normally need to
         directly use this method.</p>
     </article>

     <article id="secureFindQuery">
       <b class="method"></b>
       <b class="server"></b>
       <b class="async"></b>
       <span class="sig">secureFindQuery(query: <i>MongoDB Query</i>, perm: string, auth: authObject): <i>MongoDB Query</i></span>
       <p>This method behaves like <a href="collection#secureQuery"><u>secureQuery()</u></a> except that this method will not ever return a <u>boolean</u>.
         If the security component detects that a query is categorically rejected, this method will return a valid MongoDB query object that is guaranteed
         to fail-fast (something like <u>{ _id: null }</u>).</p>
     </article>

     <article id="subscribe">
       <b class="method"></b>
       <b class="client"></b>
       <b class="async"></b>
       <span class="sig">subscribe(query: <i>MongoDB Query</i>, cancel?: boolean): void</span>
       <p>This subscribes the current client to the given <u>query</u>.  When changes that match the given query are made the client objects
         will be updated automatically on the client with the changes.</p>
       <p>If the <u>cancel</u> parameter is passed in as true, then the given subscription will be canceled.</p>
       <p>If <u>cancel</u> is true and <u>query</u> is undefined, then all subscriptions will be canceled.</p>
     </article>

     <article id="toClient">
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">toClient(doc: <a href="document">Document</a>, opts: object?): object</span>
       <p>This creates a new POJO out of a document instance.  Values are copied by reference (not deep-cloned!).</p>
       <p><u>opts</u> can contain the following:</p>
       <table class="def">
         <thead>
           <tr><th>Option<th>Type<th>Notes
         <tbody>
           <tr><td>{</td>
           <tr><td>  auth:<td>Auth Object<td>An authorization object (a user, group, role, etc.).  This value is also accessible to hook functions like <u>Collection.def.toClient</u> and <u>post</u> below.</td>
           <tr><td>  fields:<td>MongoDB fields<td>The standard MongoDB-style fields object that specifies the projection.  Also supports <a href="/#projection">extended projection</a> syntax.
             Any field not in this projection will not be copied to the resulting <u>toClient()</u> object.
           <tr><td>  post:<td>opts => void<td>This provides a hook to perform any post-processing on the resulting document.  <u>this</u> is bound to the current document when this function is invoked.
             Note that this function is also invoked for any embedded documents as well (in this case <u>this</u> will be bound to the specific embedded document), so your function should be
             prepared to deal with potentially different types of data.</td>
           <tr><td>}</td>
       </table>
       <p>Any <u>toClient</u> function defined for a collection in its <a href="collection#def"><u><i>Collection</i>.def</u></a> will also be invoked during <u>toClient</u> processing.  This provides
        a standard place where fields can be removed for security and other reasons.  As with <u>post()</u>, <u>this</u> is bound to the current document inside a collection's <u>toClient()</u>
        post-processing function.</p>
     </article>

     <article id="update">
       <b class="method"></b>
       <b class="server"></b>
       <b class="async"></b>
       <span class="sig">update(query: object, update: object, opts: object)</span>
       <p>
        This behaves like <a href="http://mongodb.github.io/node-mongodb-native/">native MongoDB</a>'s <u>update()</u> method.  It also will
        update timestamps if this collection is configured to use them.
      </p>
     </article>

     <article id="updateDoc">
       <b class="method"></b>
       <b class="server"></b>
       <b class="async"></b>
       <span class="sig">updateDoc(doc: <a href="document">Document</a> | object, options: <a href="#options">options object</a>)</span>
       <p>This updates the server document with the values in this object.</p>
       <p>Note that the document is <b><i>not</i> replaced</b>.  See <a href="collection#save"><u>save()</u></a> if you want to do a full replace.</p>
       <p>If the document is new (it does not have an <u>_id</u>) then it will be <u>insert()</u>'ed and the new <u>_id</u> will be stored on the document.</p>
     </article>

     <article id="values">
       <b class="property"></b>
       <b class="client"></b>
       <span class="sig">values: <a href="document">Document</a>[]</span>
       <p>This contains a list of all documents that are cached locally on a client for off-line use.</p>
     </article>

     <article id="valuesFor">
       <b class="method"></b>
       <b class="server"></b>
       <b class="async"></b>
       <span class="sig">valuesFor(fields: Field[]): any[]</span>
       <p>
         This method returns all of the unique values that appear for the given fields in the collection.
       </p>
     </article>
  </div>
