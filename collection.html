<html>
 <head>
  <link href='http://fonts.googleapis.com/css?family=Megrim' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Metrophobic' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Lekton' rel='stylesheet' type='text/css'>
  <link href="tyranid.css" rel='stylesheet' type='text/css'>
 </head>
 <body>
   <div class="sidebar">
    <section>
     <h3>Overview</h3>
     <span><a href="index.html">Guide</a></span>
    </section>

    <section>
     <h3>API</h3>
     <span><a href="collection.html">Collection</a></span>
     <div>|</div>
     <span><a href="document.html">Document</a></span>
     <div>|</div>
     <span><a href="field.html">Field</a></span>
     <div>|</div>
     <span><a href="type.html">Type</a></span>
     <div>|</div>
     <span><a href="tyr.html">Tyr</a></span>
     <div>|</div>
     <span><a href="validationError.html">ValidationError</a></span>
    </section>
   </div>

  <div class="content">
    <h1>Collection</h1>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <b class="async"></b>
       <span class="sig">byId(id): <a href="document.html">Document</a></span>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="async"></b>
       <span class="sig">byIds(ids: [ <i>id</i> ] ): [ <a href="document.html">Document</a> ]</span>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <b class="async"></b>
       <span class="sig">byLabel(label: String): <a href="document.html">Document</a></span>
     </article>

     <article id="def">
       <b class="property"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">def</span>
       <pre>
{
  id: String,
  name: String,
  dbName<em>?</em>: String = name,
  label<em>?</em>: String = labelize(name),
  fields: {
    <em>fieldName</em>: <a href="field.html#def">Field Def</a>,
    <em>...</em>
  },
  methods<em>?</em>: {
    <em>methodName</em>: {
      fn<em>?</em>(<em>method parameters</em>) { <em>...</em> }       <i>// a single function for both client and server</i>
      clientFn<em>?</em>(<em>method parameters</em>) { <em>...</em> } <i>// the function to use on the client</i>
      serverFn<em>?</em>(<em>method parameters</em>) { <em>...</em> } <i>// the function to use on the server</i>
    },
    <em>...</em>
  }
}</pre>
     </article>

     <article>
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">fake({ n, schemaOpts, seed } = {}): n > 1 ? [ <a href="document.html">Document</a> ] : <a href="document.html">Document</a></span>
       <p>This creates <u>n</u> fake documents (default is 1) for fields matching <u>schemaOpts</u> using the given <u>seed</u>.</p>
     </article>

     <article id="fields">
       <b class="property"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">fields: { <i><a href="index.html#paths">field path name</a></i>: <a href="field.html">Field</a> }</span>
       <p>This is a hash of all the fields inside a collection by their <a href="index.html#paths">path names</a>.  Paths are often more
        convenient to work with than recursively walking the def.fields.* structure.</p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">fieldsBy(comparable)</span>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="async"></b>
       <span class="sig">find(...): Cursor&lt;<a href="document.html">Document</a>&gt;</span>
       <p>
        This behaves like <a href="https://github.com/gordonmleigh/promised-mongo">promised-mongo</a>'s <u>find()</u> method with the addition that results are wrapped in this
        collection's document type.
       </p>
     </article>

     <article>
       <b class="method"></b>
       <b class="client"></b>
       <b class="async"></b>
       <span class="sig">find(query: MongoDBQuery): [ <a href="document.html">Document</a> ]</span>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="async"></b>
       <span class="sig">findOne(...): <a href="document.html">Document</a></span>
       <p>
        This behaves like <a href="https://github.com/gordonmleigh/promised-mongo">promised-mongo</a>'s <u>findOne()</u> method except that the results are wrapped in this collection's
        document type.
       </p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="async"></b>
       <span class="sig">findAndModify(...)</span>
       <p>
        This behaves like <a href="https://github.com/gordonmleigh/promised-mongo">promised-mongo</a>'s <u>findAndModify()</u> method except that the results are wrapped in this collection's
        document type.
       </p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">fromClient(doc: Object, <a href="index.html#paths">path</a>: String?): <a href="document.html">Document</a></span>
       <p>
        This creates a new record instance out of a POJO.  Values are copied by reference (not deep-cloned!).
      </p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">idToUid(id): String</span>
       <p>
        This generates a <a href="index.html#uids">UID</a> from an id.
       </p>
     </article>

     <article>
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">insert(doc: <a href="document.html">Document</a> | Object)</span>
       <p>
        This behaves like <a href="https://github.com/gordonmleigh/promised-mongo">promised-mongo</a>'s <u>insert()</u> method but also
        does things like <a href="index.html#timestamps">timestamps</a>, <a href="index.html#denormalization">denormalization</a>, and so on.
       </p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">isStatic(): Boolean</span>
       <p>
        This returns true if the collection's data is defined statically in its def.values field.  Enumerations are a common example
        of static collections.
       </p>
     </article>

     <article>
       <b class="property"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">label: String</span>
       <p>This returns a label, or display name, for the collection itself.</p>
     </article>

     <article>
       <b class="property"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">labelField: <a href="field.html">Field</a></span>
       <p>If this collection has a field that is marked with <u>labelField</u> this returns the that field.</p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">labelFor(doc: <a href="document.html">Document</a> | Object)</span>
       <p>This returns the label for the specified document.  If <b>doc</b> is a Document, then this is equivalent to <u>doc.$label</u>.
        This method is mostly useful for when you have a raw Object that you want to get the label for.</p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <b class="async"></b>
       <span class="sig">labels(text: String): [ { _id, <i>label field</i>: String } ]</span>
       <p>This generates a list of label objects that can be used to populate a typeahead dropdown.</p>
       <p>Generally prefer to use <a href="field.html#labels"><u>Field.labels()</u></a> over this as it can take advantage of the <u>where</u> property on link fields.</p>
     </article>

     <article id="populate">
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">populate(fields, documents: <a href="document.html">Document</a> | [ <a href="document.html">Document</a> ], <a href="index.html#denormalization">denormal</a>: Boolean)</span>
       <p>
        Fields can take one of the following three forms:
        <ul>
         <li>String -- the name of a field to populate.
         <li>[ String ] -- an array of names of fields to populate.
         <li>Object -- object population syntax (<a href="index.html#advancedPopulation">Advanced Population</a> syntax).
        </ul>
      </p>
      <p>
        If <b>documents</b> is not provided, this function will return a curried version of this function that takes a single array
        of documents.  This allows populate to be fed into a promise chain.
      </p>
      <p>
        See <a href="index.html#population">Population</a> for more information and examples.
      </p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <b class="async"></b>
       <span class="sig">remove(id | query: Object, justOne: Boolean?)</span>
       <p>
        This behaves like <a href="https://github.com/gordonmleigh/promised-mongo">promised-mongo</a>'s <u>remove()</u> method.
       </p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <b class="async"></b>
       <span class="sig">save(doc: <a href="document.html">Document</a> | Object | [ <a href="document.html">Document</a> | Object ] ): <a href="document.html">Document</a></span>
       <p>
         This method will either update or insert the object based on whether it has an _id.
       </p>
       <p>
         When updating, only fields present in the updating <b>doc</b> are altered.  Existing properties that are not present in <thead>
         update object will not be removed (i.e. save() does not do a replace).
       </p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">toClient(doc: <a href="document.html">Document</a>): Object</span>
       <p>
        This creates a new POJO out of a record instance.  Values are copied by reference (not deep-cloned!).
       </p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="async"></b>
       <span class="sig">update(query, update, opts)</span>
       <p>
        This behaves like <a href="https://github.com/gordonmleigh/promised-mongo">promised-mongo</a>'s <u>update()</u> method.  It also will
        update timestamps if this collection is configured to use them.
      </p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="async"></b>
       <span class="sig">updateDoc(doc: <a href="document.html">Document</a> | Object)</span>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="async"></b>
       <span class="sig">valuesFor(fieldNames: [ String ])</span>
     </article>

     <h2>Hooks</h2>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">plugin(fn: Function, opts): this</span>
       <p>
        Register a plugin for this Collection. Similar API to <a href="http://mongoosejs.com/docs/plugins.html">Mongoose plugins</a>.
        Note that the hooks API *does* differ from Mongoose's.
      </p>
     </article>

     <article>
      <b class="method"></b>
      <b class="server"></b>
      <span class="sig">pre(methods: String | [ String ], cb: Function): this</span>
      <ul>
        <li><u>methods</u>: String | [ String ] -- methods method name or array of method names to add pre hook.
        <li><u>cb</u>: Function(next, ...args) -- hook callback
        <li><u>cb.next</u>: Function -- if modifying arguments, return next(modifiedArgs)
        <li><u>cb.args</u>: [ Function ] -- original method args
      </ul>
      <p>
       Add a pre hook
      </p>
     </article>

     <article>
      <b class="method"></b>
      <b class="server"></b>
      <span class="sig">post(methods, cb): this</span>
      <ul>
       <li><u>methods</u>: String | [ String ] -- method name or array of method names to add post hook
       <li><u>cb</u>: Function(next, result) -- hook callback
       <li><u>cb.next</u>: Function -- if modifying result, return next(modifiedResult)
       <li><u>cb.result</u>: [ Function ] -- original method result
      </ul>
      <p>
       Add a post hook

      </p>
     </article>

     <article>
      <b class="method"></b>
      <b class="server"></b>
      <span class="sig">unhook(methods): this</span>
      <ul>
       <li><u>methods</u>: String | [ String ] -- Method or methods. Unhooks all methods if unspecified.
      </ul>
      <p>
       Remove hooks for a particular method. Needs to be called once per pre/post() call.
      </p>
     </article>

  </div>
 </body>
</html>
