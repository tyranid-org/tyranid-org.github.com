---
layout: default
---

  <div class="content">
    <h1>Collection <span class="extends">mixins <a href="component">Component</a></span></h1>

    <article id="options">
      <span class="sig">Options</span>
      <p>A lot of <u>Collection</u> methods take an <u>options</u> parameter.  The options available are:</p>

       <table class="def">
         <thead>
           <tr><th>Option<th>Type<th>Notes
         <tbody>
           <tr><td>{</td>
           <tr><td colspan="3" class="subtitle">Query (<u>find*()</u>, <u>update()</u>, <u>remove()</u>)</td>
           <tr><td>  query:<td>MongoDB query<td>The standard MongoDB-style query object.
           <tr><td colspan="3" class="subtitle">Projection & Population (<u>find*()</u>, <u>by*()</u>)</td>
           <tr><td>  fields:<td>MongoDB fields<td>The standard MongoDB-style fields object that specifies the projection.  Also supports <a href="/#projection">extended projection</a> syntax.
           <tr><td>  populate:<td><a href="#populationFields">Population Fields</a><td>The population fields to populate.
           <tr><td colspan="3" class="subtitle">Windowing (<u>find()</u>, <u>findAll()</u>)</td>
           <tr><td>  limit:<td><u>integer</u><td>The maximum number of documents to retrieve.
           <tr><td>  skip:<td><u>integer</u><td>The number of documents to skip.
           <tr><td colspan="3" class="subtitle">Sorting (<u>find()</u>, <u>findAll()</u>, <u>byIds()</u>, <u>byUids()</u>)</td>
           <tr><td>  sort:<td>MongoDB sort<td>The standard MongoDB-style sort object.
           <tr><td colspan="3" class="subtitle">Deletions (<u>remove()</u>)</td>
           <tr><td>  justOne:<td><u>boolean</u><td>Whether to remove at most one document.
           <tr><td colspan="3" class="subtitle">Updates (<u>update()</u>, <b>but NOT</b> <u>$update()</u> or <u>updateDoc()</u>)</td>
           <tr><td>  update:<td>MongoDB update<td>The standard MongoDB-style update object.
             'insert' for <i>inserts</i>, etc.) but you can override it with this option.
           <tr><td colspan="3" class="subtitle"><a href="/#historical">Historical</a> (<i>most saving/updating methods</i>)</td>
           <tr><td>  author:<td>UID | <a href="document">Document</a><td>The author of the change that should be recorded in the historical snapshot.  If <u>author</u> is not specified
             but <u>auth</u> is, and <u>auth</u> is a <a href="document">Document</a>, then its UID will be used instead.</td>
           <tr><td>  comment:<td>string<td>A comment to record along with the historical update.</td>
           <tr><td>  historical:<td>boolean<td>Normally historical-unsafe methods log a warning if you use them with historical collections.  If you set historical to false you can suppress
            the warning indicating that you know what you are doing.</td>
           <tr><td colspan="3" class="subtitle">Timestamps (<i>most saving/updating methods</i>)</td>
           <tr><td>  timestamps:<td>boolean<td>Indicates if <a href="/#timestamps">timestamps</a> should be updated.  Defaults to the <a href="collection#def"><u>timestamps</u></a>
             setting on the collection.</td>
           <tr><td colspan="3" class="subtitle">Security (<i>most methods</i>)</td>
           <tr><td>  auth:<td>Auth Object<td>An authorization object (a user, group, role, etc.) to pass to a <a href="secure">Secure</a> plug-in.  Can also be "true" to auto-detect the current user.
           <tr><td>  perm:<td>string<td>The permission to use when an <u>auth</u> object is specified.  Usually <u>perm</u> is inferred ('view' for <i>finds</i>, 'delete' for <i>removes</i>, ...)
           <tr><td>}</td>
       </table>

       <p>Not all options are supported by all methods.  For example, <u>findOne()</u> uses a <u>limit</u> of 1 and <u>Tyr.byUid()</u> does not support the <u>query</u> option.</p>
    </article>

    <article id="populationFields">
      <span class="sig">Population Fields</span>
      <p>A population fields definition can take one of the following three forms:
        <ul>
         <li>string -- the name of a field to populate.
         <li>string[] -- an array of names of fields to populate.
         <li>object -- object population syntax (<a href="/#advancedPopulation">Advanced Population</a> syntax).
        </ul>
      </p>
    </article>

    <h2>instance</h2>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <b class="async"></b>
       <span class="sig">byId(id: <i>id type</i>, options: <a href="#options">Options</a>): <a href="document">Document</a></span>
       <p>This retrieves a document by its id.</p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="async"></b>
       <span class="sig">byIds(ids: <i>id type</i>[], options: <a href="#options">Options</a>): <a href="document">Document</a>[]</span>
       <p>This retrieves a list of documents by their ids.</p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <b class="async"></b>
       <span class="sig">byLabel(label: string): <a href="document">Document</a></span>
       <p>This retrieves the first document it finds matching the given <u>label</u> using a case-insensitive search.</p>
     </article>

     <article id="canInsert">
       <b class="method"></b>
       <b class="server"></b>
       <b class="async"></b>
       <span class="sig">canInsert(query: <i>MongoDB Query</i>, perm: string, auth: authObject): <i>MongoDB Query</i> | boolean</span>
       <p>If a <a href="secure"><u>Secure</u></a> component is registered with Tyranid, this method will be used to determine if a document can
         be inserted into a collection relative to the <u>authObject</u> (usually an instance of a user document).</p>
       <p>Most Tyranid insert and save use <u>canInsert()</u> internally when an <u>auth</u> option is used and end-users will not normally need to
         directly use this method.</p>
     </article>

     <article>
      <b class="property"></b>
      <b class="server"></b>
      <span class="sig">db: <a href="http://mongodb.github.io/node-mongodb-native/2.1/api/Collection">native MongoDB Collection</a></span>

      <p>This contains a reference to the underlying native MongoDB <u>Collection</u> instance.</p>
     </article>

     <article id="def">
       <b class="property"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">def</span>
       <p>This defines the structure of a collection and is the argument that is passed into the Collection constructor.</p>
       <table class="def">
<thead>
  <tr><th>Object Structure<th>Type<th>Default<th>Notes
</thead>
<tr><td>{</td>
<tr><td>  id:<td>string<td><i>required</i><td>3 character alphanumeric code, must be unique, see <a href="/#uids">UIDs</a>.
<tr><td>  name:<td>string<td><i>required</i>
<tr><td>  dbName:<td>string<td><i>name</i></td>
<tr><td>  server:<td>string<td><i>default server</i><td>The server to use with this collection -- see<br><u>Tyr.config({ servers: ... })</u>.</td>
<tr><td>  label:<td>string<td>labelize(<i>name</i>)<td>The human-readable <a href="/#labels">label</a> for this collection.
<tr><td>  indexes:<td>array<td><i>none</i><td>If present contains an array of index definitions in the format specified by the <a href="https://docs.mongodb.com/manual/reference/command/createIndexes/">MongoDB createIndexes command</a></td>
<tr><td>  help:<td>string<td>none<td>Contains brief user-facing documentation about this collection.
<tr><td>  historical:<td>boolean<td>none<td>Indicates if this collection should have <a href="/#historical">historical</a> data support.
<tr><td>  note:<td>string<td>none<td>Contains developer-facing documentation about this collection (only visible in the Tyranid console).
<tr><td>  enum:<td>boolean<td>false<td>Generates <a href="/#staticData">enumeration</a> support for this collection.
<tr><td>  client:<td>boolean<td>true<td>If this is false, client-side classes for this collection will not be generated.
<tr><td>  primaryKey: {<td><td>none
<tr><td>    field:<td><i>fieldName</i><td><i>required</i>
<tr><td>    defaultMatchIdOnInsert:<td>boolean<td>false
<tr><td>  },</td>
<tr><td>  timestamps:<td>boolean<td>false<td>Enables <a href="/#timestamps">timestamps</a> on this collection.
<tr><td>  <span style="color:#ccc">express: {<td><td><td><span style="color:#f00">Under construction ... disregard for now.</span>
<tr><td>    rest:<td>boolean<td>false<td>Activates all REST API endpoints.</td>
<tr><td>    get:<td>boolean<td>false
<tr><td>    post:<td>boolean<td>false
<tr><td>    put:<td>boolean<td>false
<tr><td>  },</span></td>
<tr><td>  fields: {</td>
<tr><td>    <i>fieldName</i>:<td><a href="field#def">Field Def</a></td>
<tr><td>    <i>...</i></td>
<tr><td>  },</td>
<tr><td>  methods: {<td><td><td>Define <a href="document">Document</a> methods for this collection.  See <a href="/#methods">Methods</a>.
<tr><td>    <i>methodName</i>: {</td>
<tr><td>      fn(<i>method parameters</i>) { <i>...</i> }<td>function<td>none<td>A single isomorphic function for both client and server.</td>
<tr><td>      fnClient(<i>method parameters</i>) { <i>...</i> }<td>function<td>none<td>The function to use on the client.</td>
<tr><td>      fnServer(<i>method parameters</i>) { <i>...</i> }<td>function<td>none<td>The function to use on the server.</td>
<tr><td>    },</td>
<tr><td>    <i>...</i></td>
<tr><td>  },</td>
<tr><td>  values: {<td><td>none<td>This allows you to define <a href="/#staticData">static data</a> in a tabular format.</td>
<tr><td>    [ '_id', '<i>fieldName1</i>', ... ],<td><td><td>The first row is a header row which contains field names.</td>
<tr><td>    [ <i>id1</i>,   <i>value1</i>,       ... ],<td><td><td>The following rows are data rows.</td>
<tr><td>    ...</td>
<tr><td>  }</td>
<tr><td>  projections: {</td>
<tr><td>    <i>projectionName</i>:<td><i>MongoDB-style projection</i><td><td>Define standard projections.  See <a href="/#projection">projections</a>.</td>
<tr><td>    <i>...</i></td>
<tr><td>  },</td>
<tr><td>}</td>
</table>
     </article>

     <article>
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">fake({ n, schemaOpts, seed } = {}): n > 1 ? <a href="document">Document</a>[] : <a href="document">Document</a></span>
       <p>This creates <u>n</u> fake documents (default is 1) for fields matching <u>schemaOpts</u> using the given <u>seed</u>.</p>
     </article>

     <article id="fields">
       <b class="property"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">fields: { <i>field name</a></i>: <a href="field">Field</a> }</span>
       <p>This is a parallel hash to <u>def.fields</u> that contains the generated <a href="field"><u>Field</u></a> objects.</p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">fieldsBy(filter: Field => boolean): <a href="field">Field</a>[]</span>
       <p>This returns an array of <a href="field"</a>Field</a>s that match the given filter.<p>
       <p>For example, following returns a list of all of the fields in the User collection that are of type string.</p>
       <pre>User.fieldsBy(field => field.def.is.def.name === 'string')</pre>
     </article>

     <article>
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">fieldsFor(obj): <a href="field">Field</a>[]</span>
       <p>This is similar to <u>def.fields</u> except that it also returns all fields from <a href="/#dynamicSchemas">Dynamic Schemas</a> as well.</p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="async"></b>
       <span class="sig">find(query, projection, options: <a href="#options">Options</a>): Cursor&lt;<a href="document">Document</a>&gt;</span>
       <p>
        This behaves like the <a href="http://mongodb.github.io/node-mongodb-native/">native MongoDB driver</a>'s <u>find()</u> method with the addition that results are wrapped in this
        collection's document type.
       </p>
     </article>

     <article id="findAll">
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <b class="async"></b>
       <span class="sig">findAll(<i>opts</i>): <a href="document">Document</a>[]</span>
       <p>This behaves like <a href="#find"><u>find()</u></a> except that returns an array of <a href="document">Document</a>s instead of a cursor.</p>
       <p><u><i>opts</i></u> can be one of two styles:</p>
       <ul>
         <li>the normal MongoDB find() parameters: <u>(query, projection, options: <a href="#options">Options</a>)</u>
         <li>or a single <a href="#options">Options</a> object
       </ul>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="async"></b>
       <span class="sig">findOne(query?, projection?, options: <a href="#options">Options</a>): <a href="document">Document</a></span>
       <p>
        This behaves like <a href="http://mongodb.github.io/node-mongodb-native">native MongoDB</a>'s <u>findOne()</u> method except that the results are wrapped in this collection's
        document type.  You can also just pass in a single options object and specify the query on the options object directory.
       </p>
     </article>

     <article id="findAndModify">
       <b class="method"></b>
       <b class="server"></b>
       <b class="async"></b>
       <span class="sig">findAndModify(opts: <a href="#options">Options</a>)</span>
       <p>
        This behaves like <a href="http://mongodb.github.io/node-mongodb-native/">native MongoDB</a>'s <u>findAndModify()</u> method except the options are passed in a single
        <a href="#options">Options</a> object and the results are wrapped in this collection's document type.
       </p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">fromClient(doc: object, <a href="/#paths">path</a>: string?): <a href="document">Document</a></span>
       <p>
        This creates a new document instance out of a POJO.  Values are copied by reference (not deep-cloned!).
      </p>
     </article>

     <article id="fromClientQuery">
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">fromClientQuery(query: object): object</span>
       <p>This converts a MongoDB-style query created on the client into one suitable to be used on the server.  For example:</p>
       <table>
         <tr><th>Client<th>Server
         <tr>
           <td><pre>{
  isbn: {
    $in: [
      '5614c2f00000000000000000',
      '5614c2f00000000000000001'
    ]
  }
}</pre><td><pre>{
  isbn: {
    $in: [
      ObjectId('5614c2f00000000000000000'),
      ObjectId('5614c2f00000000000000001')
    ]
  }
}</pre>
       </table>
     </article>

     <article id="idToLabel">
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">idToLabel(id: <i>id type</i>): string</span>
       <p>This returns the label for the specified <u>id</u>.</p>
       <p>This method will return an empty string if it is given a non-truthy <u>id</u> (i.e. if the id is not defined).</p>
     </article>

     <article id="idToUid">
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">idToUid(id: <i>id type</i>): <a href="/#uids">UID string</a></span>
       <p>
        This generates a <a href="/#uids">UID</a> from an id.
       </p>
     </article>

     <article>
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">insert(doc: <a href="document">Document</a> | object | <a href="document">Document</a>[] | object[])</span>
       <p>
        This behaves like <a href="http://mongodb.github.io/node-mongodb-native/">native MongoDB</a>'s <u>insert()</u> method but also
        does things like <a href="/#timestamps">timestamps</a>, <a href="/#denormalization">denormalization</a>, and so on.
       </p>
       <p>If you pass in an array, then the array of documents/objects will be inserted in bulk.</p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">isStatic(): boolean</span>
       <p>
        This returns true if the collection's data is defined statically in its def.values field.  Enumerations are a common example
        of static collections.
       </p>
     </article>

     <article id="isUid">
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">isUid(uid: <a href="/#uids">UID string</a>): boolean</span>
       <p>This returns true if the given UID refers to a document in this collection.</p>
     </article>

     <article>
       <b class="property"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">label: string</span>
       <p>This returns a label, or display name, for the collection itself.</p>
     </article>

     <article>
       <b class="property"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">labelField: <a href="field">Field</a></span>
       <p>If this collection has a field that is marked with <u>labelField</u> this returns the that field.</p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">labelFor(doc: <a href="document">Document</a> | object)</span>
       <p>This returns the label for the specified document.  If <b>doc</b> is a Document, then this is equivalent to <u>doc.$label</u>.
        This method is mostly useful for when you have a raw object that you want to get the label for.</p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <b class="async"></b>
       <span class="sig">labels(text: string): { _id: <i>id type</i>, <i>label field</i>: string }[]</span>
       <p>This generates a list of label objects that can be used to populate a typeahead dropdown.</p>
       <p>Generally prefer to use <a href="field#labels"><u>Field.labels()</u></a> over this as it can take advantage of the <u>where</u> property on link fields.</p>
     </article>

     <article id="links">
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">links(opts): <a href="field">Field</a>[]</span>
       <p>This generates a list of links between this collection and other collections.  By default this will find both outgoing links <i>and incoming links</i>
        from other collections to this one.</p>
       <p><u>opts</u> are:
       <ul>
         <li><u>relate</u>:
           <table>
             <thead>
               <tr><th>Value<th>Notes
             <tbody>
               <tr><td>'associate'<td>Only look at "associate" links.
               <tr><td>'owns'<td>Only look at "owns" links.
               <tr><td>'ownedBy'<td>Only look at "ownedBy" links.
           </table>
         <li><u>direction</u>:
           <table>
             <thead>
               <tr><th>Value<th>Notes
             <tbody>
               <tr><td>'incoming'<td>Only look at incoming links.
               <tr><td>'outgoing'<td>Only look at outgoing links.
           </table>
       </ul>
     </article>

     <article id="mixin">
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">mixin(def: <a href="#def">def Object</a>): void</span>
       <p>This allows you to mixin additional metadata (like additional fields) to an existing collection.  This is useful for adding additional metadata to built-in
         Tyranid or third-party collections.  See <a href="index#mixinSchemas">Mixins</a> for more information.</p>
     </article>

     <article id="parsePath">
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">parsePath(text: string): <a href="namePath">NamePath</a></span>
       <p>This parses a <a href="/#paths">path</a> into a <a href="namePath">NamePath</a> object.</p>
     </article>

     <article id="paths">
       <b class="property"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">paths: { <i><a href="/#paths">field path name</a></i>: <a href="field">Field</a> }</span>
       <p>This is a hash of all the fields inside a collection by their <a href="/#paths">path names</a>.  Paths are often more
        convenient to work with than recursively walking the def.fields.* structure.</p>
       <p>Note that unlike <a href="collection#fields"><u>Collection.fields</u></a> which just has the top-level fields, <u>paths</u> contains
        nested fields as well.</p>
     </article>

     <article id="populate">
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">populate(fields: <a href="#populationFields">Population Fields</a>, documents: <a href="document">Document</a> | <a href="document">Document</a>[], <a href="/#denormalization">denormal</a>: boolean)</span>
      <p>
        If <b>documents</b> is not provided, this function will return a curried version of this function that takes a single array
        of documents.  This allows populate to be fed into a promise chain.
      </p>
      <p>
        See <a href="/#population">Population</a> for more information and examples.
      </p>
     </article>

     <article id="pull">
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">pull(id: <i>id type</i>, <a href="/#paths">path</a>: string, predicate: any => boolean, opts: <a href="#options">Options</a>?)</span>
      <p>This method assumes that <u>path</u> points to an array inside the document.  This method will remove all elements of the array that match the
        <u>predicate</u> function.</p>
      <p>For example:</p>
<pre><code class="js">User.pull(myId, 'name.suffices', suffix => suffix === 'Sr');
</code></pre>
      <p>This method will also retain historical information for <a href="/#historical">historical documents</a>.
     </article>

     <article id="push">
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">push(id: <i>id type</i>, <a href="/#paths">path</a>: string, value: any, opts: <a href="#options">Options</a>?)</span>
      <p>This is a shortcut for:</p>
      <quote><u><i>collection</i>.update({ _id: id }, { $push: { [path]: value } })</u></quote>
      <p>However, this method will also atomically retain historical information for <a href="/#historical">historical documents</a>.
     </article>

     <article id="remove">
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <b class="async"></b>
       <span class="sig">remove(id: <i>id type</i> | query: object, justOne: boolean?)</span>
       <p>
        This behaves like <a href="http://mongodb.github.io/node-mongodb-native/">native MongoDB</a>'s <u>remove()</u> method.
       </p>
     </article>

     <article id="save">
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <b class="async"></b>
       <span class="sig">save(doc: <a href="document">Document</a> | object | <a href="document">Document</a>[] | object[]): <a href="document">Document</a></span>
       <p>
         This method will either update or insert the object based on whether it has an _id.
       </p>
       <p>
         When updating, the entire document is <b>replaced</b>.  Use <a href="document#updateDoc">updateDoc()</a> to only modify updated fields.
       </p>
     </article>

     <article id="secureQuery">
       <b class="method"></b>
       <b class="server"></b>
       <b class="async"></b>
       <span class="sig">secureQuery(query: <i>MongoDB Query</i>, perm: string, auth: authObject): <i>MongoDB Query</i> | boolean</span>
       <p>If a <a href="secure"><u>Secure</u></a> component is registered with Tyranid, this method will update the query with security restrictions
         the secure component mandates relative to the <u>authObject</u> (usually an instance of a user document).</p>
       <p><b>Warning:  This method will return <u>false</u> if the query is categorically rejected so it is important that the results of this
         are not immediately passed into a subsequent query.  You need to look at the result and if it is <u>false</u> short-circuit the query.</b>
         See <a href="collection#secureFindQuery"><u>secureFindQuery()</u></a>.</p>
       <p>Most Tyranid methods use <u>secureQuery</u> internally when an <u>auth</u> option is used and end-users will not normally need to
         directly use this method.</p>
     </article>

     <article id="secureFindQuery">
       <b class="method"></b>
       <b class="server"></b>
       <b class="async"></b>
       <span class="sig">secureFindQuery(query: <i>MongoDB Query</i>, perm: string, auth: authObject): <i>MongoDB Query</i></span>
       <p>This method behaves like <a href="collection#secureQuery"><u>secureQuery()</u></a> except that this method will not ever return a <u>boolean</u>.
         If the security component detects that a query is categorically rejected, this method will return a valid MongoDB query object that is guaranteed
         to fail-fast (something like <u>{ _id: null }</u>).</p>
     </article>

     <article id="toClient">
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">toClient(doc: <a href="document">Document</a>): object</span>
       <p>
        This creates a new POJO out of a document instance.  Values are copied by reference (not deep-cloned!).
       </p>
     </article>

     <article id="update">
       <b class="method"></b>
       <b class="server"></b>
       <b class="async"></b>
       <span class="sig">update(query: object, update: object, opts: object)</span>
       <p>
        This behaves like <a href="http://mongodb.github.io/node-mongodb-native/">native MongoDB</a>'s <u>update()</u> method.  It also will
        update timestamps if this collection is configured to use them.
      </p>
     </article>

     <article id="updateDoc">
       <b class="method"></b>
       <b class="server"></b>
       <b class="async"></b>
       <span class="sig">updateDoc(doc: <a href="document">Document</a> | object, opts: <a href="#options">Options</a>)</span>
       <p>This updates the server document with the values in this object.</p>
       <p>Note that the document is <b><i>not</i> replaced</b>.  See <a href="collection#save"><u>save()</u></a> if you want to do a full replace.</p>
       <p>If the document is new (it does not have an <u>_id</u>) then it will be <u>insert()</u>'ed and the new <u>_id</u> will be stored on the document.</p>
     </article>

     <article id="valuesFor">
       <b class="method"></b>
       <b class="server"></b>
       <b class="async"></b>
       <span class="sig">valuesFor(fields: Field[]): any[]</span>
       <p>
         This method returns all of the unique values that appear for the given fields in the collection.
       </p>
     </article>


     <h2>Hooks</h2>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">plugin(fn: function, opts): this</span>
       <p>
        Register a plugin for this Collection. Similar API to <a href="http://mongoosejs.com/docs/plugins.html">Mongoose plugins</a>.
        Note that the hooks API *does* differ from Mongoose's.
      </p>
     </article>

     <article>
      <b class="method"></b>
      <b class="server"></b>
      <span class="sig">pre(methods: string | string[], cb: function): this</span>
      <ul>
        <li><u>methods</u>: string | string[] -- methods method name or array of method names to add pre hook.
        <li><u>cb</u>: function(next, ...args) -- hook callback
        <li><u>cb.next</u>: function -- if modifying arguments, return next(modifiedArgs)
        <li><u>cb.args</u>: function[] -- original method args
      </ul>
      <p>
       Add a pre hook
      </p>
     </article>

     <article>
      <b class="method"></b>
      <b class="server"></b>
      <span class="sig">post(methods, cb): this</span>
      <ul>
       <li><u>methods</u>: string | string[] -- method name or array of method names to add post hook
       <li><u>cb</u>: function(next, result) -- hook callback
       <li><u>cb.next</u>: function -- if modifying result, return next(modifiedResult)
       <li><u>cb.result</u>: function[] -- original method result
      </ul>
      <p>
       Add a post hook

      </p>
     </article>

     <article>
      <b class="method"></b>
      <b class="server"></b>
      <span class="sig">unhook(methods): this</span>
      <ul>
       <li><u>methods</u>: string | string[] -- Method or methods. Unhooks all methods if unspecified.
      </ul>
      <p>
       Remove hooks for a particular method. Needs to be called once per pre/post() call.
      </p>
     </article>

  </div>
