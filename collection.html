---
layout: default
---

  <div class="content">
    <h1>Collection <span class="extends">mixins <a href="component">Component</a></span></h1>

    <article id="options">
      <span class="sig">Options</span>
      <p>A lot of <u>Collection</u> methods take an <u>options</u> parameter.  The options available are:</p>

       <table class="def">
         <thead>
           <tr><th>Option<th>Type<th>Notes
         <tbody>
           <tr><td>{</td>
           <tr><td colspan="3" class="subtitle">Query (<u>find*()</u>, <u>update()</u>, <u>remove()</u>)</td>
           <tr><td>  query:<td>MongoDB query<td>The standard MongoDB-style query object.
           <tr><td colspan="3" class="subtitle">Projection & Population (<u>find*()</u>, <u>by*()</u>)</td>
           <tr><td>  projection:<td>MongoDB fields<td>The standard MongoDB-style fields projection that specifies the projection.  Also supports <a href="/#projection">extended projection</a> syntax.  This also can be called "fields", but this is deprecated.
           <tr><td>  populate:<td><a href="#populationProjection">Population Projection</a><td>The population fields to populate.
           <tr><td>  asOf:<td>date<td>Indicates that any <a href="/#historical">historical</a> documents (including populated documents) should be <a href="document#$asOf"><u>$asOf()</u></a>'d the given date.
           <tr><td colspan="3" class="subtitle">Windowing (<u>find()</u>, <u>findAll()</u>)</td>
           <tr><td>  limit:<td>integer<td>The maximum number of documents to retrieve.
           <tr><td>  skip:<td>integer<td>The number of documents to skip.
           <tr><td>  count:<td>boolean<td>If set on <u>findAll()</u> calls then the returned documents array will have a <u>count</u> property indicating the total number of
             documents matching the query (ignoring any <u>skip</u> and <u>limit</u>). See <a href="index#counting">Counting</a>.
           <tr><td colspan="3" class="subtitle">Sorting (<u>find()</u>, <u>findAll()</u>, <u>byIds()</u>, <u>byUids()</u>)</td>
           <tr><td>  sort:<td>MongoDB sort<td>The standard MongoDB-style sort object.
           <tr><td colspan="3" class="subtitle">Parallel Arrays (<u>byIds()</u>, <u>byUids()</u>)</td>
           <tr><td>  parallel:<td>boolean<td>If true, then the returning array will be parallel to the input array of IDs/UIDs.
           <tr><td colspan="3" class="subtitle">Caching (<u>byIds()</u>, <u>byUids()</u>)</td>
           <tr><td>  cached:<td>boolean<td>If true, then the returning array will return cached values if they are present to avoid a query.
             (Currently only availabe in the client-side API.)
           <tr><td colspan="3" class="subtitle">Deletions (<u>remove()</u>)</td>
           <tr><td>  justOne:<td>boolean<td>Whether to remove at most one document.

           <tr><td colspan="3" class="subtitle">Updates - Query (<u>update()</u>, <b>but NOT</b> <u>$update()</u> or <u>updateDoc()</u>)</td>
           <tr><td>  update:<td>MongoDB update<td>The standard MongoDB-style update object.
             'insert' for <i>inserts</i>, etc.) but you can override it with this option.

           <tr><td colspan="3" class="subtitle">Updates - Document (<u>$update()</u> and <u>updateDoc()</u>, <b>but NOT</b> <u>update()</u>)</td>
           <tr><td>  upsert:<td>boolean<td>Indicates if the document should be <i>insert()</i>'ed if no ID field is present.  (Default <u>false</u>.)

           <tr><td colspan="3" class="subtitle"><a href="/#historical">Historical</a> (<i>most saving/updating methods</i>)</td>
           <tr><td>  author:<td>UID | <a href="document">Document</a><td>The author of the change that should be recorded in the historical snapshot.  If <u>author</u> is not specified
             but <u>auth</u> is, and <u>auth</u> is a <a href="document">Document</a>, then its UID will be used instead.</td>
           <tr><td>  comment:<td>string<td>A comment to record along with the historical update.</td>
           <tr><td rowspan="3">  historical:<td><u>false</u><td>Normally historical-unsafe methods log a warning if you use them with historical collections.

            If you set <u>historical</u> to false you can suppress the warning indicating that you know what you are doing.
            Additionally, if this flag is passed on an operation that does support historical operations, this option will suppress updating the history --
            use with caution.
           <tr><td>true<td>Process history normally -- this is the default value.
           <tr><td>'partial'<td>If <u>'partial'</u> is specified and the collection is a <a href="/#historical_document">using the historical document format</a>, then the smallest
              possible historical snapshot will be saved instead of a full snapshot (i.e. <u>_partial</u> will be <u>true</u> if not all the fields changed).</td>
           <tr><td colspan="3" class="subtitle">Timestamps (<i>most saving/updating methods</i>)</td>
           <tr><td>  timestamps:<td>boolean<td>Indicates if <a href="/#timestamps">timestamps</a> should be updated.  Defaults to the <a href="collection#def"><u>timestamps</u></a>
             setting on the collection.</td>

           <tr><td colspan="3" class="subtitle">Security (<i>most methods</i>)</td>
           <tr><td>  auth:<td>Auth Object<td>An authorization object (a user, group, role, etc.) to pass to a <a href="secure">Secure</a> plug-in.  Can also be "true" to auto-detect the current user.
           <tr><td>  perm:<td>string<td>The permission to use when an <u>auth</u> object is specified.  Usually <u>perm</u> is inferred ('view' for <i>finds</i>, 'delete' for <i>removes</i>, ...)
           <tr><td>  keepNonAccessible:<td>boolean<td>If present this means to <i>not</i> filter the documents when querying and only to call <a href="document#$checkAccess()"><u>Document.$checkAccess()</u></a> on the documents.
           <tr><td colspan="3" class="subtitle">Post-processing (<i>toClient()/$toClient()</i>)</td>
           <tr><td>  post:<td>opts => void<td>This provides a hook to perform any post-processing on the resulting document.  <u>this</u> is bound to the current document when this function is invoked.
             Note that this function is also invoked for any embedded documents as well (in this case <u>this</u> will be bound to the specific embedded document), so your function should be
             prepared to deal with potentially different types of data.</td>
           <tr><td colspan="3" class="subtitle">Plain 'ole JavaScript Object (POJO) conversion (<i>find*()/by*()</i>)</td>
           <tr><td>  plain:<td>opts => void<td>This indicates that returned documents should be raw POJO objects, not <a href="document">Document</a> instances.
           <tr><td>}</td>
       </table>

       <p>Not all options are supported by all methods.  For example, <u>findOne()</u> uses a <u>limit</u> of 1 and <u>Tyr.byUid()</u> does not support the <u>query</u> option.</p>
    </article>

    <article id="populationProjection">
      <span class="sig">Population Projection</span>
      <p>A population projection definition can take one of the following three forms:
        <ul>
         <li>string -- the name of a field to populate.
         <li>string[] -- an array of names of fields to populate.
         <li>object -- object population syntax (<a href="/#advancedPopulation">Advanced Population</a> syntax).
        </ul>
      </p>
    </article>

    <h2>instance</h2>

     <article id="$metaType">
       <b class="property"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">$metaType: 'collection'</span>
       <p>This returns 'collection'.</p>
     </article>

     <article id="ajax">
       <b class="method"></b>
       <b class="client"></b>
       <b class="async"></b>
       <span class="sig">ajax(url: string, opts: <i>options</i>): <i>data</i></span>
       <p>This is a method used by Tyranid internally to make its AJAX calls but which is also available as part of Tyranid's public API.</p>
       <p>The API is essentially the same as <a href="https://api.jquery.com/jquery.ajax/">jQuery's <u>$.ajax()</u> method</a> which is currently
        used for the underlying implementation.</p>
       <p>If the <u>csrf</u> option is enabled in <a href="tyr#config"><u>Tyr.config()</u></a>, then CSRF will be applied to all <u>Tyr.ajax</u> calls automatically.</p>
     </article>

     <article id="aux">
       <b class="method"></b>
       <b class="client"></b>
       <span class="sig">aux(def: { [fieldName: string]: FieldDefinition }): void</span>
       <p>This method can be used to add new <a href="aux#fields">auxiliary fields</a> to an existing collection.  The syntax is the same as the values provided
        to <u>fields</u> when defining a collection.  For example:</p>

<pre><code class="js">User.aux({
  someClientValue: { is: 'string' }
});</code></pre>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <b class="async"></b>
       <span class="sig">byId(id: <i>id type</i>, opts: <a href="#options">options</a>): <a href="document">Document</a></span>
       <p>This retrieves a document by its id.</p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <b class="async"></b>
       <span class="sig">byIds(ids: <i>id type</i>[], opts: <a href="#options">options</a>): <a href="document">Document</a>[]</span>
       <p>This retrieves a list of documents by their ids.</p>
       <p><b>The returned array is <i>parallel</i> to the given <u>ids</u> array if the <u>parallel</u> option is passed as in options.</b>
         If the same id shows up multiple times in the input query, then the returned array will also have multiple instances, but the
         instances will be shared.  If a given id does not exist in the database, then the corresponding entry will still be present, but
         it will contain <u>null</u>.</p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <b class="async"></b>
       <span class="sig">byLabel(label: string): <a href="document">Document</a></span>
       <p>This retrieves the first document it finds matching the given <u>label</u> using a case-insensitive search.</p>
     </article>

     <article id="cache">
       <b class="method"></b>
       <b class="client"></b>
       <div class="sig" style="display: flex">
         <div>cache(</div>
         <div>document: <a href="document">Document</a> | object,<br>type: 'insert' | 'update' | 'remove',<br>silent: boolean = false</div>
         <div style="position: relative; top: 46px">): <a href="document">Document</a></div>
       </div>
       <p style="clear: both">This method can be used to manually cache a document into the local Tyranid offline cache.</p>
       <p>This can be useful for when a document
         comes back from a non-Tyranid server API call and you want to inform Tyranid about the updated document.</p>
       <p>If Tyranid already had a local copy of the document then the existing document will be updated with the new information and the
         existing document will be returned.</p>
       <p>If <u>silent</u> is set then local events will not be fired.</p>
     </article>

     <article id="canInsert">
       <b class="method"></b>
       <b class="server"></b>
       <b class="async"></b>
       <span class="sig">canInsert(query: <i>MongoDB Query</i>, perm: string, auth: authObject): <i>MongoDB Query</i> | boolean</span>
       <p>If a <a href="secure"><u>Secure</u></a> component is registered with Tyranid, this method will be used to determine if a document can
         be inserted into a collection relative to the <u>authObject</u> (usually an instance of a user document).</p>
       <p>Most Tyranid insert and save use <u>canInsert()</u> internally when an <u>auth</u> option is used and end-users will not normally need to
         directly use this method.</p>
     </article>

     <article id="count">
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <b class="async"></b>
       <span class="sig">count(<i>opts</i>: <a href="#options">options</a>): number</span>
       <p>This returns a count of the documents that match the given <u>opts.query</u>.
       <p>See also <a href="index#counting">Counting</a> and also <a href="#exists">exists()</a>.
     </article>

     <article>
      <b class="property"></b>
      <b class="server"></b>
      <span class="sig">db: <a href="http://mongodb.github.io/node-mongodb-native/2.1/api/Collection">native MongoDB Collection</a></span>

      <p>This contains a reference to the underlying native MongoDB <u>Collection</u> instance.</p>
     </article>

     <article id="def">
       <b class="property"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">def</span>
       <p>This defines the structure of a collection and is the argument that is passed into the Collection constructor.</p>
       <table class="def">
<thead>
  <tr><th>Object Structure<th>Type<th>Default<th>Notes
</thead>
<tr><td>{</td>
<tr><td>  id:<td>string<td><i>required</i><td>3 character alphanumeric code, must be unique, see <a href="/#uids">UIDs</a>.
<tr><td>  name:<td>string<td><i>required</i>
<tr><td>  dbName:<td>string<td><i>name</i></td>
<tr><td>  aux:<td>boolean<td>false<td>If this collection is auxiliary.
<tr><td>  server:<td>string<td><i>default server</i><td>The server to use with this collection -- see<br><u>Tyr.config({ servers: ... })</u>.</td>
<tr><td>  label:<td>string<td>labelify(<i>name</i>)<td>The human-readable <a href="/#labels">label</a> for this collection.
<tr><td>  indexes:<td>array<td><i>none</i><td>If present contains an array of index definitions in the format specified by the <a href="https://docs.mongodb.com/manual/reference/command/createIndexes/">MongoDB createIndexes command</a></td>
<tr><td>  help:<td>string<td>none<td>Contains brief user-facing documentation about this collection.
<tr><td>  historical:<td>'document' | 'patch'<td>none<td>Indicates if this collection should have <a href="/#historical">historical</a> data support.
<tr><td>  preserveInitialValues:<td><a href="document">Document</a> => boolean | boolean<td>none<td>This function is invoked on a document, if it returns true then a copy of the initial values is preserved in a <u>$orig</u> value.
<tr><td>  note:<td>string<td>none<td>Contains developer-facing documentation about this collection (only visible in the Tyranid console).
<tr><td>  enum:<td>boolean<td>false<td>Generates <a href="/#staticData">enumeration</a> support for this collection.
<tr><td>  static:<td>boolean<td>false<td>Generates <a href="/#staticData">static data</a> support for this collection.
<tr><td>  internal:<td>boolean<td>false<td>Indicates that this is a collection used internally by Tyranid.
<tr><td>  generated:<td>boolean<td>false<td>Indicates that this is a collection was generated automatically.
<tr><td>  client:<td>boolean<td>true<td>If this is false, client-side classes for this collection will not be generated.
<tr><td>  primaryKey: {<td><td>none
<tr><td>    field:<td><i>fieldName</i><td><i>required</i>
<tr><td>    defaultMatchIdOnInsert:<td>boolean<td>false
<tr><td>  },</td>
<tr><td>  timestamps:<td>boolean<td>false<td>Enables <a href="/#timestamps">timestamps</a> on this collection.
<tr><td>  <span>express: {
<tr><td>    rest:<td>boolean<td>false<td>Activates all REST API endpoints.</td>
<tr><td>    get:<td>boolean<td>false
<tr><td>    post:<td>boolean<td>false
<tr><td>    put:<td>boolean<td>false
<tr><td>  },</span></td>
<tr><td>  fields: {</td>
<tr><td>    <i>fieldName</i>:<td><a href="field#def">Field Def</a></td>
<tr><td>    <i>...</i></td>
<tr><td>  },</td>
<tr><td>  methods: {<td><td><td>Define <a href="document">Document</a> methods for this collection.  See <a href="/#methods">Methods</a>.
<tr><td>    <i>methodName</i>: {</td>
<tr><td>      help:<td>string<td>none<td>Contains brief user-facing documentation about this method.
<tr><td>      note:<td>string<td>none<td>Contains developer-facing documentation about this method (only visible in the Tyranid console or in IDEs).
<tr><td>      params: {<td><td><td>Define parameters for this method.
<tr><td>        <i>paramName</i>:<td><a href="field#def">Field Def</a></td>
<tr><td>      },</td>
<tr><td>      return:<td><a href="field#def">Field Def</a><td><td>Defines the return type.
<tr><td>      fn(<i>method parameters</i>) { <i>...</i> }<td>function<td>none<td>A single isomorphic function for both client and server.</td>
<tr><td>      fnClient(<i>method parameters</i>) { <i>...</i> }<td>function<td>none<td>The function to use on the client.</td>
<tr><td>      fnServer(<i>method parameters</i>) { <i>...</i> }<td>function<td>none<td>The function to use on the server.</td>
<tr><td>    },</td>
<tr><td>    <i>...</i></td>
<tr><td>  },</td>
  All result types are automatically wrapped in a <u>Promise</u>. If not specified, this will return <u>Promise<void></u>.
<tr><td>  values: {<td><td>none<td>This allows you to define <a href="/#staticData">static data</a> in a tabular format.</td>
<tr><td>    [ '_id', '<i>fieldName1</i>', ... ],<td><td><td>The first row is a header row which contains field names.</td>
<tr><td>    [ <i>id1</i>,   <i>value1</i>,       ... ],<td><td><td>The following rows are data rows.</td>
<tr><td>    ...</td>
<tr><td>  }</td>
<tr><td>  projections: {</td>
<tr><td>    <i>projectionName</i>:<td><i>MongoDB-style projection</i><td><td>Define standard projections.  See <a href="/#projection">projections</a>.</td>
<tr><td>    <i>...</i></td>
<tr><td>  },</td>
<tr><td>  service: {<td><td><td>Define a <a href="services">service</a> for this collection.
<tr><td>    <i>serviceMethodName</i>: {</td>
<tr><td>      help:<td>string<td>none<td>Contains brief user-facing documentation about this service method.
<tr><td>      note:<td>string<td>none<td>Contains developer-facing documentation about this service method (only visible in the Tyranid console or in IDEs).
<tr><td>      params: {<td><td><td>Define parameters for this service method.
<tr><td>        <i>paramName</i>:<td><a href="field#def">Field Def</a></td>
<tr><td>      },</td>
<tr><td>      return:<td><a href="field#def">Field Def</a><td><td>Defines the return type.
  All result types are automatically wrapped in a <u>Promise</u>. If not specified, this will return <u>Promise<void></u>.
<tr><td>      route:<td>string<td>/api/<i>collection name</i>/<i>service method name</i><td>This defines the HTTP route for this service.  This does not usually need to be manually specified.
<tr><td>    },</td>
<tr><td>  },</td>
<tr><td>  values: {<td><td>none<td>This allows you to define <a href="/#staticData">static data</a> in a tabular format.</td>
<tr><td>    [ '_id', '<i>fieldName1</i>', ... ],<td><td><td>The first row is a header row which contains field names.</td>
<tr><td>    [ <i>id1</i>,   <i>value1</i>,       ... ],<td><td><td>The following rows are data rows.</td>
<tr><td>    ...</td>
<tr><td>  }</td>
<tr><td>  fromClient:<td>async? opts => void<td>
  <td>Specifies a <a href="collection#fromClient"><u><i>Collection</i>.fromClient()</u></a> post-processing hook that will be applied for this collection.
  <p>This callback can be asynchronous.
<tr><td>  toClient:<td>opts => void<td><td>Specifies a <a href="collection#toClient"><u><i>Collection</i>.toClient()</u></a> post-processing hook that will be applied for this collection.</p>
<tr><td>  linkEvents:<td><a href="event#linkHandlers">object</a><td>none<td>Defines <a href="event#linkHandlers">link event handlers</a> recommended or required by this collection.  See <a href="event">Event</a> for more information.</p>
<tr><td>}</td>
</table>
     </article>

     <article id="exists">
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <b class="async"></b>
       <span class="sig">exists(<i>opts</i>: <a href="#options">options</a>): boolean</span>
       <p>This returns true if any documents that match the given <u>opts.query</u> (and permission checks).
       <p>See also <a href="#count">count()</a>.
     </article>

     <article>
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">fake({ n, schemaOpts, seed } = {}): n > 1 ? <a href="document">Document</a>[] : <a href="document">Document</a></span>
       <p>This creates <u>n</u> fake documents (default is 1) for fields matching <u>schemaOpts</u> using the given <u>seed</u>.</p>
     </article>

     <article id="fields">
       <b class="property"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">fields: { <i>field name</a></i>: <a href="field">Field</a> }</span>
       <p>This is a parallel hash to <u>def.fields</u> that contains the generated <a href="field"><u>Field</u></a> objects.</p>
     </article>

     <article id="fire">
       <b class="method"></b>
       <b class="server"></b>
       <b class="async"></b>
       <span class="sig">fire(event: <a href="event#eventObject">Event</a>): void</span>
       <p>This method fires off an event that is bound to this collection.</p>
       <pre><i>MyCollection</i>.fire({ ... });</pre>
       <p>is shorthand for:</p>
       <pre>Tyr.Event.fire({ collection: <i>MyCollection</i>, ... });</pre>
       <p>See <a href="event#fire"><u>Event.fire()</u></a> for more information.</p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">fieldsBy(filter: Field => boolean): <a href="field">Field</a>[]</span>
       <p>This returns an array of <a href="field"</a>Field</a>s that match the given filter.<p>
       <p>For example, following returns a list of all of the fields in the User collection that are of type string.</p>
       <pre>User.fieldsBy(field => field.def.is.def.name === 'string')</pre>
     </article>

     <article id="fieldsFor">
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">fieldsFor(opts: { match: MongoDocument | <a href="document">Document</a>,
         <div style="margin-left:274px;">query?: MongoQuery,</div>
         <div style="margin-left:274px;">custom?: boolean,</div>
         <div style="margin-left:274px">static?: boolean }): { <i>fieldName</i>: <a href="field">Field</a> }</div></span>
       <p>This is similar to <u>def.fields</u> except that it returns dynamic fields defined in <a href="/#dynamicSchemas">Dynamic Schemas</a>.</p>
       <p>Only one of <u>match</u> and <u>query</u> should be provided.</p>
       <p>If
         <ul>
           <li><b>match</b> is given, then it should be a document that will be matched against the schema match values.
           <li><b>query</b> is given, then it should be a mongo-style query that will be executed against the schema match values for
            a match.
         </ul>
       </p>
       <p>If <u>static</u> is specified, then all statically defined fields will also be returned -- by default only dynamic fields are returned.</p>
       <p>If <u>custom</u> is specified, then only dynamic fields which have <u>custom: true</u> set on them will be returned.</p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="async"></b>
       <span class="sig">find(opts: <a href="#options">options</a>): Cursor&lt;<a href="document">Document</a>&gt;</span>
       <p>
        This behaves like the <a href="http://mongodb.github.io/node-mongodb-native/">native MongoDB driver</a>'s <u>find()</u> method with the addition that results are wrapped in this
        collection's document type.
       </p>
     </article>

     <article id="findAll">
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <b class="async"></b>
       <span class="sig">findAll(opts: <a href="#options">options</a>): <a href="document">Document</a>[]</span>
       <p>This behaves like <a href="#find"><u>find()</u></a> except that it returns an array of <a href="document">Document</a>s instead of a cursor.</p>
       <p><u>findAll()</u> also supports the <a href="index#counting"><u>count</u></a> option.</p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <b class="async"></b>
       <span class="sig">findOne(opts: <a href="#options">options</a>): <a href="document">Document</a></span>
       <p>
        This behaves like <a href="http://mongodb.github.io/node-mongodb-native">native MongoDB</a>'s <u>findOne()</u> method except that the results are wrapped in this collection's
        document type.  You can also just pass in a single options object and specify the query on the options object directory.
       </p>
     </article>

     <article id="findAndModify">
       <b class="method"></b>
       <b class="server"></b>
       <b class="async"></b>
       <span class="sig">findAndModify(opts: <a href="#options">options</a>)</span>
       <p>
        This behaves like <a href="http://mongodb.github.io/node-mongodb-native/">native MongoDB</a>'s <u>findAndModify()</u> method except the options are passed in a single
        <a href="#options">options</a> object and the results are wrapped in this collection's document type.
       </p>
     </article>

     <article id="findReferences">
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">findReferences(opts): <a href="document">Document</a>[]</span>
       <p>This finds all the documents that link to the given id(s) in the database.  This will also find any <a href="/#uids">UID</a> references.</p>
       <table class="def">
<thead>
  <tr><th>Option<th>Type<th>Notes
</thead>
<tr><td>{</td>
<tr><td>  id:<td><i>id type</i> | <i>id type</i>[]<td>Contains an id or an array of ids to find references to.
<tr><td>  ids:<td><i>id type</i> | <i>id type</i>[]<td>Alias for "id"
<tr><td>  idsOnly:<td>boolean<td>By default the full documents are returned.  If this is returned, the documents only contain their id.
<tr><td>  exclude:<td><a href="collection">Collection</a> | <a href="collection">Collection</a>[]<td>Contains a list of collections to exclude from the search.
<tr><td>}</td>
</table>
     </article>

     <article id="fromClient">
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">fromClient(doc: object, <a href="/#paths">path</a>: string?, opts: object?): <a href="document">Document</a></span>
       <p>
        This creates a new document instance out of a POJO.  Values are copied by reference (not deep-cloned!).
      </p>
      <p>
        If this collection has a <u>fromClient</u> hook registered it will be invoked.  If Tyranid is itself calling <u>fromClient()</u>
        (for example, via automatically-generated client calls), it will pass in the express request object in the options objects available
        as <u>options.req</u>.
      </p>
     </article>

     <article id="fromClientQuery">
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">fromClientQuery(query: object): object</span>
       <p>This converts a MongoDB-style query created on the client into one suitable to be used on the server.  For example:</p>
       <table>
         <tr><th>Client<th>Server
         <tr>
           <td><pre>{
  isbn: {
    $in: [
      '5614c2f00000000000000000',
      '5614c2f00000000000000001'
    ]
  }
}</pre><td><pre>{
  isbn: {
    $in: [
      ObjectId('5614c2f00000000000000000'),
      ObjectId('5614c2f00000000000000001')
    ]
  }
}</pre>
       </table>
     </article>

     <article id="id">
       <b class="property"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">id: string</span>
       <p>This contains the 3-character ID for the collection.</p>
       <p>IDs that start with <u>_</u> are reserved for Tyranid collections and IDs that start with <u>~</u> are reserved for <a href="aux">auxiliary collections</a>.</p>
     </article>

     <article id="idToLabel">
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">idToLabel(id: <i>id type</i>): string</span>
       <p>This returns the label for the specified <u>id</u>.</p>
       <p>This method will return an empty string if it is given a non-truthy <u>id</u> (i.e. if the id is not defined).</p>
     </article>

     <article id="idToUid">
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">idToUid(id: <i>id type</i>): <a href="/#uids">UID string</a></span>
       <p>
        This generates a <a href="/#uids">UID</a> from an id.
       </p>
     </article>

     <article>
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">insert(doc: <a href="document">Document</a> | object | <a href="document">Document</a>[] | object[])</span>
       <p>
        This behaves like <a href="http://mongodb.github.io/node-mongodb-native/">native MongoDB</a>'s <u>insert()</u> method but also
        does things like <a href="/#timestamps">timestamps</a>, <a href="/#denormalization">denormalization</a>, and so on.
       </p>
       <p>If you pass in an array, then the array of documents/objects will be inserted in bulk.</p>
     </article>

     <article id="isAux">
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">isAux(): boolean</span>
       <p>This returns true if the collection's data is <a href="aux">auxiliary</a> (i.e. not presisted in the database).
        This is the opposite of <a href="#isDb">isDb()</a>.</p>
     </article>

     <article id="isDb">
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">isDb(): boolean</span>
       <p>This returns true if the collection's data is stored in the database.  This is the opposite of <a href="#isAux">isAux()</a>.</p>
     </article>

     <article id="isSingleton">
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">isSingleton(): boolean</span>
       <p>This returns true if the collection is a <a href="aux#singleton">singleton collection</a>.
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">isStatic(): boolean</span>
       <p>
        This returns true if the collection's data is defined statically in its def.values field.  Enumerations are a common example
        of static collections.
       </p>
     </article>

     <article id="isUid">
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">isUid(uid: <a href="/#uids">UID string</a>): boolean</span>
       <p>This returns true if the given UID refers to a document in this collection.</p>
     </article>

     <article>
       <b class="property"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">label: string</span>
       <p>This returns a label, or display name, for the collection itself.</p>
     </article>

     <article>
       <b class="property"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">labelField: <a href="field">Field</a></span>
       <p>If this collection has a field that is marked with <u>labelField</u> this returns the that field.</p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">labelFor(doc: <a href="document">Document</a> | object): string</span>
       <p>This returns the label for the specified document.  If <b>doc</b> is a Document, then this is equivalent to <u>doc.$label</u>.
        This method is mostly useful for when you have a raw object that you want to get the label for.</p>
     </article>

     <article id="labels">
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <b class="async"></b>
       <span class="sig">labels(text: string): { _id: <i>id type</i>, <i>label field</i>: string }[]</span><br>
       <span class="sig">labels(ids: string[]): { _id: <i>id type</i>, <i>label field</i>: string }[]</span>
       <p>This generates a list of label objects that can be used to populate a typeahead dropdown.</p>
       <p>Generally prefer to use <a href="field#labels"><u>Field.labels()</u></a> over this as it can take advantage of the <u>where</u> property on link fields.</p>
     </article>

     <article id="links">
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">links(opts): <a href="field">Field</a>[]</span>
       <p>This generates a list of links between this collection and other collections.  By default this will find both outgoing links <i>and incoming links</i>
        from other collections to this one.</p>
       <p><u>opts</u> are:
       <ul>
         <li><u>relate</u>:
           <table>
             <thead>
               <tr><th>Value<th>Notes
             <tbody>
               <tr><td>'associate'<td>Only look at "associate" links.
               <tr><td>'owns'<td>Only look at "owns" links.
               <tr><td>'ownedBy'<td>Only look at "ownedBy" links.
           </table>
         <li><u>direction</u>:
           <table>
             <thead>
               <tr><th>Value<th>Notes
             <tbody>
               <tr><td>'incoming'<td>Only look at incoming links.
               <tr><td>'outgoing'<td>Only look at outgoing links.
           </table>
       </ul>
     </article>

     <article id="migratePatchToDocument">
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">migratePatchToDocument(progress?: (count: number) => void): void</span>
       <p>This function will migrate a collection with patch-format historical data to one with document-format historical data.</p>
       <p>The <u>progress</u> parameter is a callback that will be called periodically with the number of documents that have
        been converted.  For example:</p>
       <pre><code class="js">Widget.migratePatchToDocument(count => console.log(`converted ${count} documents`))</code></pre>
     </article>

     <article id="mixin">
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">mixin(def: <a href="#def">def Object</a>): void</span>
       <p>This allows you to mixin additional metadata (like additional fields) to an existing collection.  This is useful for adding additional metadata to built-in
         Tyranid or third-party collections.  See <a href="index#mixinSchemas">Mixins</a> for more information.</p>
     </article>

     <article id="on">
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">on(opts: object): () => void</span>
       <p>Lets you add an event handler on this collection.  See <a href="event#on"><u>on()</u></a> for more information on this method.</p>
     </article>

     <article id="parsePath">
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">parsePath(text: string): <a href="path">Path</a></span>
       <p>This parses a <a href="/#paths">path</a> into a <a href="path">Path</a> object.</p>
       <p>See also <a href="document#$parsePath"><u><i>Document</i>.parsePath</u></a>.</p>
     </article>

     <article id="paths">
       <b class="property"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">paths: { <i><a href="/#paths">field path name</a></i>: <a href="field">Field</a> }</span>
       <p>This is a hash of all the fields inside a collection by their <a href="/#paths">path names</a>.  Paths are often more
        convenient to work with than recursively walking the def.fields.* structure.</p>
       <p>Note that unlike <a href="collection#fields"><u>Collection.fields</u></a> which just has the top-level fields, <u>paths</u> contains
        nested fields as well.</p>
     </article>

     <article id="populate">
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">populate(projection: <a href="#populationProjection">Population Projection</a>, documents: <a href="document">Document</a> | <a href="document">Document</a>[], <a href="/#denormalization">denormal</a>: boolean)</span>
      <p>
        If <b>documents</b> is not provided, this function will return a curried version of this function that takes a single array
        of documents.  This allows populate to be fed into a promise chain.
      </p>
      <p>
        See <a href="/#population">Population</a> for more information and examples.
      </p>
     </article>

     <article id="pull">
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">pull(id: <i>id type</i>, <a href="/#paths">path</a>: string, predicate: any => boolean, opts: <a href="#options">options</a>?)</span>
      <p>This method assumes that <u>path</u> points to an array inside the document.  This method will remove all elements of the array that match the
        <u>predicate</u> function.</p>
      <p>For example:</p>
<pre><code class="js">User.pull(myId, 'name.suffices', suffix => suffix === 'Sr');
</code></pre>
      <p>This method will also retain historical information for <a href="/#historical">historical documents</a>.
     </article>

     <article id="push">
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">push(id: <i>id type</i>, <a href="/#paths">path</a>: string, value: any, opts: <a href="#options">options</a>?)</span>
      <p>This is a shortcut for:</p>
      <quote><u><i>collection</i>.update({ _id: id }, { $push: { [path]: value } })</u></quote>
      <p>However, this method will also atomically retain historical information for <a href="/#historical">historical documents</a>.
     </article>

     <article id="remove">
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <b class="async"></b>
       <span class="sig">remove(id: <i>id type</i> | query: object, justOne: boolean?)</span>
       <p>
        This behaves like <a href="http://mongodb.github.io/node-mongodb-native/">native MongoDB</a>'s <u>remove()</u> method.
       </p>
     </article>

     <article id="removeReferences">
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">removeReferences(opts): void</span>
       <p>This finds all references in documents that link to the given id(s) in the database and removes them.  This will also remove any <a href="/#uids">UID</a>
        references.</p>
       <table class="def">
<thead>
  <tr><th>Option<th>Type<th>Notes
</thead>
<tr><td>{</td>
<tr><td>  id:<td><i>id type</i> | <i>id type</i>[]<td>Contains an id or an array of ids to remove references to.
<tr><td>  ids:<td><i>id type</i> | <i>id type</i>[]<td>Alias for "id"
<tr><td>  exclude:<td><a href="collection">Collection</a> | <a href="collection">Collection</a>[]<td>Contains a list of collections to exclude from the removal.
<tr><td>}</td>
</table>
     </article>

     <article id="save">
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <b class="async"></b>
       <span class="sig">save(doc: <a href="document">Document</a> | object | <a href="document">Document</a>[] | object[]): <a href="document">Document</a></span>
       <p>
         This method will either update or insert the object based on whether it has an _id.
       </p>
       <p>
         When updating, the entire document is <b>replaced</b>.  Use <a href="document#updateDoc">updateDoc()</a> to only modify updated fields.
       </p>
     </article>

     <article id="secureQuery">
       <b class="method"></b>
       <b class="server"></b>
       <b class="async"></b>
       <span class="sig">secureQuery(query: <i>MongoDB Query</i>, perm: string, auth: authObject): <i>MongoDB Query</i> | boolean</span>
       <p>If a <a href="secure"><u>Secure</u></a> component is registered with Tyranid, this method will update the query with security restrictions
         the secure component mandates relative to the <u>authObject</u> (usually an instance of a user document).</p>
       <p><b>Warning:  This method will return <u>false</u> if the query is categorically rejected so it is important that the results of this
         are not immediately passed into a subsequent query.  You need to look at the result and if it is <u>false</u> short-circuit the query.</b>
         See <a href="collection#secureFindQuery"><u>secureFindQuery()</u></a>.</p>
       <p>Most Tyranid methods use <u>secureQuery</u> internally when an <u>auth</u> option is used and end-users will not normally need to
         directly use this method.</p>
     </article>

     <article id="secureFindQuery">
       <b class="method"></b>
       <b class="server"></b>
       <b class="async"></b>
       <span class="sig">secureFindQuery(query: <i>MongoDB Query</i>, perm: string, auth: authObject): <i>MongoDB Query</i></span>
       <p>This method behaves like <a href="collection#secureQuery"><u>secureQuery()</u></a> except that this method will not ever return a <u>boolean</u>.
         If the security component detects that a query is categorically rejected, this method will return a valid MongoDB query object that is guaranteed
         to fail-fast (something like <u>{ _id: null }</u>).</p>
     </article>

     <article id="subscribe">
       <b class="method"></b>
       <b class="client"></b>
       <b class="async"></b>
       <span class="sig">subscribe(query: <i>MongoDB Query</i>, cancel?: boolean): void</span>
       <p>This subscribes the current client to the given <u>query</u>.  When changes that match the given query are made the client objects
         will be updated automatically on the client with the changes.</p>
       <p>If the <u>cancel</u> parameter is passed in as true, then the given subscription will be canceled.</p>
       <p>If <u>cancel</u> is true and <u>query</u> is undefined, then all subscriptions will be canceled.</p>
     </article>

     <article id="toClient">
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">toClient(doc: <a href="document">Document</a>, opts: object?): object</span>
       <p>This creates a new POJO out of a document instance.  Values are copied by reference (not deep-cloned!).</p>
       <p><u>opts</u> can contain the following:</p>
       <table class="def">
         <thead>
           <tr><th>Option<th>Type<th>Notes
         <tbody>
           <tr><td>{</td>
           <tr><td>  auth:<td>Auth Object<td>An authorization object (a user, group, role, etc.).  This value is also accessible to hook functions like <u>Collection.def.toClient</u> and <u>post</u> below.</td>
           <tr><td>  fields:<td>MongoDB fields<td>The standard MongoDB-style fields object that specifies the projection.  Also supports <a href="/#projection">extended projection</a> syntax.
             Any field not in this projection will not be copied to the resulting <u>toClient()</u> object.
           <tr><td>  post:<td>opts => void<td>This provides a hook to perform any post-processing on the resulting document.  <u>this</u> is bound to the current document when this function is invoked.
             Note that this function is also invoked for any embedded documents as well (in this case <u>this</u> will be bound to the specific embedded document), so your function should be
             prepared to deal with potentially different types of data.</td>
           <tr><td>}</td>
       </table>
       <p>Any <u>toClient</u> function defined for a collection in its <a href="collection#def"><u><i>Collection</i>.def</u></a> will also be invoked during <u>toClient</u> processing.  This provides
        a standard place where fields can be removed for security and other reasons.  As with <u>post()</u>, <u>this</u> is bound to the current document inside a collection's <u>toClient()</u>
        post-processing function.</p>
       <p><u>$toClient()</u> will also invoke the <a href="document#$redact"><u>Document.$redact()</u></a> method on documents.</p>
     </article>

     <article id="update">
       <b class="method"></b>
       <b class="server"></b>
       <b class="async"></b>
       <span class="sig">update(query: object, update: object, opts: <a href="#options">options</a>)</span>
       <p>
        This behaves like <a href="http://mongodb.github.io/node-mongodb-native/">native MongoDB</a>'s <u>update()</u> method.  It also will
        update timestamps if this collection is configured to use them.
      </p>
     </article>

     <article id="updateDoc">
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <b class="async"></b>
       <span class="sig">updateDoc(doc: <a href="document">Document</a> | object, opts: <a href="#options">options</a>): <a href="document"><u>Document</u></a></span>
       <p>This updates the server document with the values in this object.</p>
       <p>Note that the document is <b><i>not</i> replaced</b>.  See <a href="collection#save">Collection<u>.save()</u></a> if you want to do a full replace.</p>
       <p>If the document is new (it does not have an <u>_id</u>) then an exception will be thrown unless the <u>upsert</u> option is set to <u>true</u>.</p>
     </article>

     <article id="values">
       <b class="property"></b>
       <b class="client"></b>
       <span class="sig">values: <a href="document">Document</a>[]</span>
       <p>This contains a list of all documents that are cached locally on a client for off-line use.</p>
     </article>

     <article id="valuesFor">
       <b class="method"></b>
       <b class="server"></b>
       <b class="async"></b>
       <span class="sig">valuesFor(fields: Field[]): any[]</span>
       <p>
         This method returns all of the unique values that appear for the given fields in the collection.
       </p>
     </article>
  </div>
