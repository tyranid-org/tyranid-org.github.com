---
layout: default
---

  <div class="content">
    <h1>Collection</h1>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <b class="async"></b>
       <span class="sig">byId(id: <i>id type</i>): <a href="document">Document</a></span>
       <p>This retrieves a document by its id.</p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="async"></b>
       <span class="sig">byIds(ids: <i>id type</i>[] ): <a href="document">Document</a>[]</span>
       <p>This retrieves a list of documents by their ids.</p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <b class="async"></b>
       <span class="sig">byLabel(label: string): <a href="document">Document</a></span>
       <p>This retrieves the first document it finds matching the given <u>label</u> using a case-insensitive search.</p>
     </article>

     <article id="def">
       <b class="property"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">def</span>
       <p>This defines the structure of a collection and is the argument that is passed into the Collection constructor.</p>
       <table class="def">
<thead>
  <tr><th>Object Structure<th>Type<th>Default<th>Notes
</thead>
<tr><td>{</td>
<tr><td>  id:<td>string<td><i>required</i><td>3 character alphanumeric code, must be unique, see <a href="/#uids">UIDs</a>.
<tr><td>  name:<td>string<td><i>required</i>
<tr><td>  dbName:<td>string<td><i>name</i></td>
<tr><td>  label:<td>string<td>labelize(<i>name</i>)<td>The human-readable <a href="/#labels">label</a> for this collection.
<tr><td>  help:<td>string<td>none<td>Contains brief user-facing documentation about this collection.
<tr><td>  note:<td>string<td>none<td>Contains developer-facing documentation about this collection (only visible in the Tyranid console).
<tr><td>  enum:<td>boolean<td>false<td>Generates <a href="/#staticData">enumeration</a> support for this collection.
<tr><td>  client:<td>boolean<td>true<td>If this is false, client-side classes for this collection will not be generated.
<tr><td>  primaryKey: {<td><td>none
<tr><td>    field:<td><i>fieldName</i><td><i>required</i>
<tr><td>    defaultMatchIdOnInsert:<td>boolean<td>false
<tr><td>  },</td>
<tr><td>  timestamps:<td>boolean<td>false<td>Enables <a href="/#timestamps">timestamps</a> on this collection.
<tr><td>  <span style="color:#ccc">express: {<td><td><td><span style="color:#f00">Under construction ... disregard for now.</span>
<tr><td>    rest:<td>boolean<td>false<td>Activates all REST API endpoints.</td>
<tr><td>    get:<td>boolean<td>false
<tr><td>    post:<td>boolean<td>false
<tr><td>    put:<td>boolean<td>false
<tr><td>  },</span></td>
<tr><td>  fields: {</td>
<tr><td>    <i>fieldName</i>:<td><a href="field#def">Field Def</a></td>
<tr><td>    <i>...</i></td>
<tr><td>  },</td>
<tr><td>  methods: {<td><td><td>Define <a href="document">Document</a> methods for this collection.  See <a href="/#methods">Methods</a>.
<tr><td>    <i>methodName</i>: {</td>
<tr><td>      fn(<i>method parameters</i>) { <i>...</i> }<td>function<td>none<td>A single isomorphic function for both client and server.</td>
<tr><td>      fnClient(<i>method parameters</i>) { <i>...</i> }<td>function<td>none<td>The function to use on the client.</td>
<tr><td>      fnServer(<i>method parameters</i>) { <i>...</i> }<td>function<td>none<td>The function to use on the server.</td>
<tr><td>    },</td>
<tr><td>    <i>...</i></td>
<tr><td>  },</td>
<tr><td>  values: {<td><td>none<td>This allows you to define <a href="/#staticData">static data</a> in a tabular format.</td>
<tr><td>    [ '_id', '<i>fieldName1</i>', ... ],<td><td><td>The first row is a header row which contains field names.</td>
<tr><td>    [ <i>id1</i>,   <i>value1</i>,       ... ],<td><td><td>The following rows are data rows.</td>
<tr><td>    ...</td>
<tr><td>  }</td>
<tr><td>}</td>
</table>
     </article>

     <article>
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">fake({ n, schemaOpts, seed } = {}): n > 1 ? <a href="document">Document</a>[] : <a href="document">Document</a></span>
       <p>This creates <u>n</u> fake documents (default is 1) for fields matching <u>schemaOpts</u> using the given <u>seed</u>.</p>
     </article>

     <article id="fields">
       <b class="property"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">fields: { <i><a href="/#paths">field path name</a></i>: <a href="field">Field</a> }</span>
       <p>This is a hash of all the fields inside a collection by their <a href="/#paths">path names</a>.  Paths are often more
        convenient to work with than recursively walking the def.fields.* structure.</p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">fieldsBy(filter: Field => boolean): <a href="field">Field</a>[]</span>
       <p>This returns an array of <a href="field"</a>Field</a>s that match the given filter.<p>
       <p>For example, following returns a list of all of the fields in the User collection that are of type string.</p>
       <pre>User.fieldsBy(field => field.def.is.def.name === 'string')</pre>
     </article>

     <article>
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">fieldsFor(obj): <a href="field">Field</a>[]</span>
       <p>This is similar to <u>def.fields</u> except that it also returns all fields from <a href="/#dynamicSchemas">Dynamic Schemas</a> as well.</p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="async"></b>
       <span class="sig">find(...): Cursor&lt;<a href="document">Document</a>&gt;</span>
       <p>
        This behaves like <a href="https://github.com/gordonmleigh/promised-mongo">promised-mongo</a>'s <u>find()</u> method with the addition that results are wrapped in this
        collection's document type.
       </p>
     </article>

     <article>
       <b class="method"></b>
       <b class="client"></b>
       <b class="async"></b>
       <span class="sig">find(query: MongoDBQuery): <a href="document">Document</a>[]</span>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="async"></b>
       <span class="sig">findOne(...): <a href="document">Document</a></span>
       <p>
        This behaves like <a href="https://github.com/gordonmleigh/promised-mongo">promised-mongo</a>'s <u>findOne()</u> method except that the results are wrapped in this collection's
        document type.
       </p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="async"></b>
       <span class="sig">findAndModify(...)</span>
       <p>
        This behaves like <a href="https://github.com/gordonmleigh/promised-mongo">promised-mongo</a>'s <u>findAndModify()</u> method except that the results are wrapped in this collection's
        document type.
       </p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">fromClient(doc: object, <a href="/#paths">path</a>: string?): <a href="document">Document</a></span>
       <p>
        This creates a new document instance out of a POJO.  Values are copied by reference (not deep-cloned!).
      </p>
     </article>

     <article id="fromClientQuery">
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">fromClientQuery(query: object): object</span>
       <p>This converts a MongoDB-style query created on the client into one suitable to be used on the server.  For example:</p>
       <table>
         <tr><th>Client<th>Server
         <tr>
           <td><pre>{
  isbn: {
    $in: [
      '5614c2f00000000000000000',
      '5614c2f00000000000000001'
    ]
  }
}</pre><td><pre>{
  isbn: {
    $in: [
      ObjectId('5614c2f00000000000000000'),
      ObjectId('5614c2f00000000000000001')
    ]
  }
}</pre>
       </table>
     </article>

     <article id="idToLabel">
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">idToLabel(id: <i>id type</i>): string</span>
       <p>This returns the label for the specified <u>id</u>.</p>
       <p>This method will return an empty string if it is given a non-truthy <u>id</u> (i.e. if the id is not defined).</p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">idToUid(id: <i>id type</i>): string</span>
       <p>
        This generates a <a href="/#uids">UID</a> from an id.
       </p>
     </article>

     <article>
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">insert(doc: <a href="document">Document</a> | object)</span>
       <p>
        This behaves like <a href="https://github.com/gordonmleigh/promised-mongo">promised-mongo</a>'s <u>insert()</u> method but also
        does things like <a href="/#timestamps">timestamps</a>, <a href="/#denormalization">denormalization</a>, and so on.
       </p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">isStatic(): boolean</span>
       <p>
        This returns true if the collection's data is defined statically in its def.values field.  Enumerations are a common example
        of static collections.
       </p>
     </article>

     <article>
       <b class="property"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">label: string</span>
       <p>This returns a label, or display name, for the collection itself.</p>
     </article>

     <article>
       <b class="property"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">labelField: <a href="field">Field</a></span>
       <p>If this collection has a field that is marked with <u>labelField</u> this returns the that field.</p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <span class="sig">labelFor(doc: <a href="document">Document</a> | object)</span>
       <p>This returns the label for the specified document.  If <b>doc</b> is a Document, then this is equivalent to <u>doc.$label</u>.
        This method is mostly useful for when you have a raw object that you want to get the label for.</p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <b class="async"></b>
       <span class="sig">labels(text: string): { _id: <i>id type</i>, <i>label field</i>: string }[]</span>
       <p>This generates a list of label objects that can be used to populate a typeahead dropdown.</p>
       <p>Generally prefer to use <a href="field#labels"><u>Field.labels()</u></a> over this as it can take advantage of the <u>where</u> property on link fields.</p>
     </article>

     <article id="parsePath">
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">parsePath(text: string): <a href="namePath">NamePath</a></span>
       <p>This parses a <a href="/#paths">path</a> into a <a href="namePath">NamePath</a> object.</p>
     </article>

     <article id="populate">
       <b class="async"></b>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">populate(fields, documents: <a href="document">Document</a> | <a href="document">Document</a>[], <a href="/#denormalization">denormal</a>: boolean)</span>
       <p>
        Fields can take one of the following three forms:
        <ul>
         <li>string -- the name of a field to populate.
         <li>string[] -- an array of names of fields to populate.
         <li>object -- object population syntax (<a href="/#advancedPopulation">Advanced Population</a> syntax).
        </ul>
      </p>
      <p>
        If <b>documents</b> is not provided, this function will return a curried version of this function that takes a single array
        of documents.  This allows populate to be fed into a promise chain.
      </p>
      <p>
        See <a href="/#population">Population</a> for more information and examples.
      </p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <b class="async"></b>
       <span class="sig">remove(id: <i>id type</i> | query: object, justOne: boolean?)</span>
       <p>
        This behaves like <a href="https://github.com/gordonmleigh/promised-mongo">promised-mongo</a>'s <u>remove()</u> method.
       </p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="client"></b>
       <b class="async"></b>
       <span class="sig">save(doc: <a href="document">Document</a> | object | <a href="document">Document</a>[] | object[] ): <a href="document">Document</a></span>
       <p>
         This method will either update or insert the object based on whether it has an _id.
       </p>
       <p>
         When updating, only fields present in the updating <b>doc</b> are altered.  Existing properties that are not present in <thead>
         update object will not be removed (i.e. save() does not do a replace).
       </p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">toClient(doc: <a href="document">Document</a>): object</span>
       <p>
        This creates a new POJO out of a document instance.  Values are copied by reference (not deep-cloned!).
       </p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="async"></b>
       <span class="sig">update(query: object, update: object, opts: object)</span>
       <p>
        This behaves like <a href="https://github.com/gordonmleigh/promised-mongo">promised-mongo</a>'s <u>update()</u> method.  It also will
        update timestamps if this collection is configured to use them.
      </p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="async"></b>
       <span class="sig">updateDoc(doc: <a href="document">Document</a> | object)</span>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <b class="async"></b>
       <span class="sig">valuesFor(fields: Field[]): any[]</span>
       <p>
         This method returns all of the unique values that appear for the given fields in the collection.
       </p>
     </article>

     <h2>Hooks</h2>

     <article id="boot">
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">boot(stage: string, pass: number): string | string[]</span>
       <p>Tyranid will call collection <u>boot()</u> methods once all collections have passed compilation and and then again after linking/validation.  Return a string
         (or an array of strings) listing human-readable reasons for dependencies that you are waiting for.</p>
       <p>Tyranid will keep calling <u>boot()</u> methods until all boot methods that exist return false/an empty array or until 100 passes have occured, in which
         case it will give up and throw an exception (a deadlock).</p>
       <p><u>stage</u> is either <u>'compile'</u> or <u>'link'</u>.</p>
       <p><u>pass</u> starts at 1 and increases after each pass through all the collections by one up to a maximum of 100.</p>
       <p>In general your boot hook should get everything accomplished it can before returning dependencies.  It should only return dependencies if it is waiting on
         another collection or component to do something in its boot method.</p>
       <p><b>Your <u>boot()</u> should be <i>idempotent</i> since it may be called multiple times.</b></p>
     </article>

     <article>
       <b class="method"></b>
       <b class="server"></b>
       <span class="sig">plugin(fn: function, opts): this</span>
       <p>
        Register a plugin for this Collection. Similar API to <a href="http://mongoosejs.com/docs/plugins.html">Mongoose plugins</a>.
        Note that the hooks API *does* differ from Mongoose's.
      </p>
     </article>

     <article>
      <b class="method"></b>
      <b class="server"></b>
      <span class="sig">pre(methods: string | string[], cb: function): this</span>
      <ul>
        <li><u>methods</u>: string | string[] -- methods method name or array of method names to add pre hook.
        <li><u>cb</u>: function(next, ...args) -- hook callback
        <li><u>cb.next</u>: function -- if modifying arguments, return next(modifiedArgs)
        <li><u>cb.args</u>: function[] -- original method args
      </ul>
      <p>
       Add a pre hook
      </p>
     </article>

     <article>
      <b class="method"></b>
      <b class="server"></b>
      <span class="sig">post(methods, cb): this</span>
      <ul>
       <li><u>methods</u>: string | string[] -- method name or array of method names to add post hook
       <li><u>cb</u>: function(next, result) -- hook callback
       <li><u>cb.next</u>: function -- if modifying result, return next(modifiedResult)
       <li><u>cb.result</u>: function[] -- original method result
      </ul>
      <p>
       Add a post hook

      </p>
     </article>

     <article>
      <b class="method"></b>
      <b class="server"></b>
      <span class="sig">unhook(methods): this</span>
      <ul>
       <li><u>methods</u>: string | string[] -- Method or methods. Unhooks all methods if unspecified.
      </ul>
      <p>
       Remove hooks for a particular method. Needs to be called once per pre/post() call.
      </p>
     </article>

  </div>
